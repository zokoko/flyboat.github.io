

## 常用技巧

### 导航器修改不了样式，需继承父class父元素

```
那么我们可以通过包含选择题增加权重，找到父元素的class名，添加到前面就可以

.nav .noborder{border-left: 0;}
1
OK，基本上咱们遇到的错误有这几种，总结一下：

没有相应CSS属性，查引入路径或看选择符前是否多加标点
出现感叹号被拉掉，单词拼写错误或属性属性值不匹配
出现属性被拉掉但没有感叹号，权重不够
```



## 原型与原型链

```
JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性。而原型链是一个实现对象间联系即继承的主要方法。

function Person() {

}

var person = new Person();

console.log(person.__proto__ == Person.prototype) // true
console.log(Person.prototype.constructor == Person) // true
// 顺便学习一个ES5的方法,可以获得对象的原型
console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

### 原型

```
. 什么是原型
JavaScript是一种简易的脚本语言，其是由对象构成。每一个JavaScript对象（除null外）都和另一个对象相关联，“另一个”对象就是原型。也就是说，任何一个对象都有原型这个属性。

隐式原型（_proto_）：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_。隐式原型的作用是用来构成原型链，实现基于原型的继承
显示原型（prototype）：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象。显示原型的作用是用来实现基于原型的继承与属性的共享
```

### 那原型是用来做什么的？其可以解决什么问题？

```
1.共享数据

function Person(name) {
    this.name = name 
}
Person.prototype = {
    address: "上海"
}

//生成人对象实例
var person1 = new Person('Tom')
var person2 = new Person('Jack')

//修改共享的属性address
Person.prototype.address = "北京"
console.log(person1.prototype) // 北京
console.log(person2.prototype) // 北京

2.继承机制
//原型链
function SuperType() {
    this.property = true 
}
SuperType.prototype.getSuperValue = function(){
    return this.property
}
function SubType () {
    this.subproperty = false
}
//继承了SubType
SubType.prototype = new SuperType()
SubType.prototype.getSubValue = function () {
    return this.subproperty
}
var instance = new SubType()
console.log(instance.getSuperValue())
首先先定义了两个类型：SuperType和SubType，每个类型分别有一个属性和方法，通过创建SuperType实例让SubType继承SuperType，并且将SuperType实例赋值给SubType.prototype。这样就将原来存放在SuperType的实例中的所有属性和方法共享到SubType.prototype中。
然后再给SubType.prototype添加一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。
```



## 箭头函数并没有 `this`

## 常见面试题

```
前端
面试问题：
１、数组的去重方法
利用ES6 Set去重（ES6中最常用）
function unique (arr) {   return Array.from(new Set(arr)) }
利用for嵌套for，然后splice去重（ES5中最常用）
２、keep-alive使用场景一般是什么

设置了keep-alive的组件
第一次进入： beforeRouteEnter => created => ... => activated => ... => deactivated
后续进入：beforeRouteEnter => activated => deactivated,
只有第一次进入该组件时，才会走created钩子，需要缓存的组件中activated时每次都会走的钩子函数

场景 Vue中前进刷新，后退缓存用户浏览数据
列表页面 =>点击进入详情页=> 后退到列表页 要缓存列表原来数据
重新进入列表页面 => 获取最新的数据

３、用过什么数组方法
push()、pop()、shift()和unshift()
push()方法可以在数组的末属添加一个或多个元素
shift()方法把数组中的第一个元素删除
unshift()方法可以在数组的前端添加一个或多个元素
pop()方法把数组中的最后一个元素删除

４、生命周期有哪些？beformount里有dom吗？
beforeCreate\created\beforeMount\mounted\beforeUpdate\updated\beforeDestroy\destroyed
mounted里形成真正的dom

beforeCreate

在实例初始化之后，数据观测和事件、生命周期初始化配置之前被调用。

created

实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测，属性和方法的运算，事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

beforeMount

在挂载开始之前被调用：相关的 render 函数首次被调用，此时有了虚拟DOM。

mounted

el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子，渲染为真实DOM。

beforeUpdate

在数据更新之前时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。

updated

由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。

值得注意的是：该钩子在服务器端渲染期间不被调用。

beforeDestroy

实例销毁之前调用。此时，实例仍然是可用的。

destroyed

vue 实例销毁后调用。调用后，vue 实例指示的所有东西都会解绑，所有的事件监听器会被卸载移除，所有的子实例也会被销毁。 

值得注意的是：该钩子在服务器端渲染期间不被调用。



1、http协议、Tcp三次握手、封装组件
请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体
应答报文格式如下：
状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体

通道的建立——三次握手：
（1）在建立通道时，客户端首先要向服务端发送一个SYN同步信号。
（2）服务端在接收到这个信号之后会向客户端发出SYN同步信号和ACK确认信号。
（3）当服务端的ACK和SYN到达客户端后，客户端与服务端之间的这个“通道”就会被建立起来。
通道的关闭——四次挥手：
（1）在数据传输完毕之后，客户端会向服务端发出一个FIN终止信号。
（2）服务端在收到这个信号之后会向客户端发出一个ACK确认信号。
（3）如果服务端此后也没有数据发给客户端时服务端会向客户端发送一个FIN终止信号。
（4）客户端在收到这个信号之后会回复一个确认信号，在服务端接收到这个信号之后，服务端与客户端的通道也就关闭了。



2、vue中钩子函数、原型链、闭包



1、深拷贝和浅拷贝
2、es6语法
Map用法：键值对
箭头函数 和 this
Promise使用
```

![img](https://upload-images.jianshu.io/upload_images/14507358-10f8f266a8e0a1ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/715/format/webp)

![img](https://upload-images.jianshu.io/upload_images/14507358-981b2c1f2d66d14b.png?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp)

## 网络集合



```


请问 AJAX 的原理是什么？AJAX 就是异步的 JS 和 XML 的缩写，目前我们一般用 JSON 代替 XML。AJAX 主要用于在不刷新页面的情况下向浏览器发起请求并接受响应，最后局部更新页面。该技术最核心概念是 XMLHttpRequest 对象，该对象可发起 HTTP 请求，我们可以监听其 readystate 的变化获得响应。具体代码是这样的 blablabla优点刚才说了，无刷新请求。缺点是被浏览器限制不能跨域。想要跨越就要用到 JSONP 或 CORS 了。


接下来面试官可能问 JSONP 的原理，解题思路如下：JSONP 是 json with padding 的缩写该技术通过 script 不受同源策略限制来达到跨域的目的该技术核心是前端构造 script 发起 get 请求，后端将数据放到 js 回调里，前端接受响应后执行回调拿到数据具体代码是 blablabla优点是通过简单的约定就能跨域缺点是不支持 get 以外的动词，而且存在 csrf 风险解决办法是 CORS 或 csrf token你看，按照我的步骤就能得满分。

面试官可能还会再问 CORS 的原理，答题示例：CORS 是跨域资源共享的缩写该技术通过在目标域名返回 CORS 响应头来达到获取该域名的数据的目的改技术核心就是设置 response header，分为简单请求和复杂请求两种简单请求只需要设置 Access-Control-Allow-Origin: 目标源 即可，复杂请求则分两步走，第一步是浏览器发起 OPTIONS 请求，第二步才是真实请求。OPTIONS 请求需要把服务器支持的操作通过响应头来表明，如 Access-Control-Allow-Methods: POST, GET, OPTIONS，另外一个重要的响应头是 Access-Control-Allow-Credentials: true 用来表明是否接受请求中的 Cookie。blablabla优点是通过简单的配置就能跨域缺点是某些古老浏览器不支持 CORS 或不支持 Credentials解决办法是用 JSONP 或 P3P 等技术

1、描述一下JavaScript中的数据类型？（就是基本类型和引用类型，有些面试人员基本类型会叫做值类型）

答：基本类型有String、Number、Boolean、Null、Undefined。剩下的都是引用类型，Array、Object、Date，Function等。

追问： 怎么判断基本类型和引用类型？

答： 只有单一的一个值，只存放在栈中。比如说字符串、数字、布尔这几个就是一个单一的值，他们就是基本类型。剩下的就是引用类型，引用类型就是对象。Function、Object、Array、Date等在js里都属性对象。引用类型是同时存储在堆栈中，我们访问的是栈上的变量标识符（变量名字）和指向该类型指向堆中的内存地址。



2、javascript中prototype是什么，描述一下js中的原型链？（大部分公司会问）

答：在js中函数也属于对象，每个函数都有一个子对象prototype,  prototype就是该函数的原型，包含一个类的所有成员。在js里类是以函数的形式呈现（ js使用function来声明一个类，使用new创造一个实例（Object），新的es6提供了一个语法糖class来声明一个类，相对去function来说结构更清晰 ）。

    通过new的过程，类（function）中的所有成员都会实例成Object中的属性。Object的属性__proto__和function的属性prototype都指向了同一个对象（原型对象）。原型既然是对象，那也必须通过某一个类（function）来实现（实例），这个地方就是继承的关键，一般来讲外我们不设计继承的话他默认继承Object,这个就是js的顶层对象，如果你要在这里继承于某个对象，比如说son类（function）继承于father(Object),那就可以通过prototype实现继承。然后father是默认继承Object, Object作为一个对象，那他就有构造函数（他自己的类 function）。Objecet由Object()的函数实例过来，所以我们在在创建对象的时候可以写成 new Object();Object上面是null，空对象指针。所有的函数都会继承于一个顶层函数Function()。这样son到father到Object到null,下面的对象都能访问到上层对象属性，而对象又是类（function）的实例。所有的function继承于顶层函数Function(), 所以函数会默认由3个方法bind,apply,call 3个方法 这就是继承自顶层函数Function()。不然函数后面怎么能使用点号来访问一个方法。let son = function ( ) { }.bind(father); 这个bind()就是继承Function()用于改变指针。(这个内容或多或少会问到，我写的有点乱，知识点有点抽象，大家可以搜集一些文章来看，建议看比较有权威的书本里面的讲解)

7、闭包是什么，闭包的优缺点，闭包里面的this指针指向哪里？     

答： 闭包就是定义在函数内部的子函数。他可以在外部访问函数内部的变量。 闭包的优点就是外部能访问函数内部的变量，缺点是变量会一直存储在内存里。闭包的this指向window或者是global。

追问：为什么闭包的this指向的是window?

答： 闭包的结构为父函数里嵌套子函数，要调用子函数父函数必须把子函数return出来。上面说到过this指向函数执行时候的上下文，父函数执行时被可能会被某个对象调用指向该对象，但是父函数执行完成之后返回的子函数就不被任何对象调用，相当于执行在window上，所以闭包的this指向的是window。

8、数组和对象上的方法有哪些？（考点在于对数据的处理能力，虽然不同公司问法可能有些差别，但是思路是一样的。有些公司可能会给一些数据然后把数据处理成想要的内容）

答： 常用的数组方法有: join(数组转字符)、push(添加元素)，pop(删除末尾元素并返回)，sort(数组排序)，reverse(反转数组)， concat(链接数组)，includs(查找数组是含有某一个，返回true)， find(查找是否函数元素，返回元素), findIndex(查找是否含有元素，返回下标，没有返回-1)， filter(过滤数组，返回新的数组),slice(切割数组)，splice(删除数组)

常用的对象方法： assign（对象合并），create(创建对象)，keys(返回键数组)，hasOwnProperty(判断是否含有指定的属性)。其它的有很多，但是不常见。


9、说一下深拷贝和浅拷贝？（这个问题会经常被问,也是一个小核心内容）

答：浅拷贝和深拷贝只在引用类型上由区别，基本类型没差别。潜拷贝就是简单的赋值，在引用类型上变量的简单赋值变换只是变量标识符，比如说let a = [1,2,3]; let b = a; 这种浅拷贝只是变换了变量的名称，他们的内存地址（引用地址，在堆里面的地址）还是一样的。如果改变b，b.push(4)，则a也会被改变。深拷贝就是在内存里开辟一个新的内存地址用来存储新变量，相对于潜拷贝他不仅仅是简单的赋值，他还在堆里创建了新的内存地址，改变b就不会影响到a。常用的深拷贝方法， 我这边是转成JSON在转过来。Let b = JSON.parse(JSON.stringify(a))。

12、描述一下es6、es7的新特性？（说常用特性即可）

答：新的变量声明方式let const ; 解构赋值； 箭头函数；新异步函数Promise;async

await ,新数据结构Set, Map。新的类声明方式class。遍历方式map, forEach, for...of 。 以及一些常用的数组对象方法includes、filter等

追问：新特性解决哪些问题？

答：1.  let const： 解决var声明变量没有块级作用域的问题，let 和const都不能重复声明，const 值不能被修改。

2.箭头函数：函数的this指针是其运行时的上下文，箭头函数的指针在函数定义时候所在的对象，而不是运行时候的对象，减少了赋值指针的操作。箭头函数的书写更简洁。

3. Promise、async、await 新的异步函数。（这个内容使用面广，也是es新特性中比较重要的一个内容，大部分公司或多或少都会问到这个问题，下面会单独提出来问）

4.新数据结构Set, Map: Set数据结构和数组上基本一模一样，优点在于Set数据里面不存在重复的值，可以使用new Set（）对数组进行查重。排除重复的值或者做一些其它的事情。Map:在老的数据类型中，对象的属性名称只能是一个字符串，（字符串--值）的结构，而Map（Map也是键值对的数据结构）里属性名可以变成值（值--值的结构）是一个更完善的Hash结构。

14、浏览器有哪些数据存储方法？区别在哪？

答： cookie,sessionStorage,localStorage.（浏览器下的storage对象）

Cookie： 早期的前端开发中大量使用的一种存储技术。在比较早的网站里服务器发送到客服端的数据的响应头里可以设置存储一些值到客户端的cookie里方便客户端和服务器联系。如登录等信息。在下一次客户端对改服务器发送请求的时候都会将cookie发送到服务器用于验证用户信息（登录状态等）。Cookie也可以用来存储其它一些客户端的内容优化客户端的体验。Cookie可以自定义设置值、域、过期时间等。大小为4M内。

sessionStorage: 继承于Storage的存储，页面关闭消失。存储大小为5M左右，不同浏览器存储大小有差别。

LocalStorage: 同样继承与Storage，页面关闭不会消失。永久存储，除非手动清除或使用clear方法清除。谷歌最大5M左右，不同浏览器存储大小有差别。

15、前端的优化过程？

答： 优化方法有很多，减少http请求，压缩css html js 文件(gulp等构建工具就有压缩功能)，压缩image图片，使用icon, 减少重绘，减少dom节点，预加载、按需加载、雪碧图等很多方法。

16、跨域有几种？ 怎么解决跨域问题？原理？

答: 浏览器对js的同源策略限制，不同域之间不能相互访问，所以出现了跨域问题。同域为相同端口、协议、域名。Jquery中的话是使用Jsonp。（使用jquery多的话就会问你jsonp的问题，使用vue多就会问代理的问题，vue的proxyType是将请求发送给自己的服务器，在由服务器转向后台服务器，实现浏览器跨域，和jsonp有区别）

Jsonp的基本原理：jsonp是一种为了处理跨域问题的一种方案，像ajax,但是他并不是ajax。ajax获取不到存在跨域问题的文件的，因为受到同源策略的影响，但是页面上的使用script标签引入文件是不受影响，比如说<script src=“www.aaa.cn/page/index.js”> 这种情况是能访问到这个js文件。不仅是js文件，带有src的标签都不会受到同源策略的影响。那jsonp就可以理解为你在页面添加了一个script标签，服务器为我们生成js文件，script标签指向这个js文件地址，callback为js文件里面存放数据的函数名字，服务器动态生成js,script标签去取js文件里的callback 函数名字内的参数。所以jsonp和ajax的不同就在于ajax是new XMLHttpRequest() 来获取文件，jsonp使用script标签来引入存储了数据的js文件来解决跨域问题。在Jquery中看起来都是在使用数据请求，但是jsonp和ajax是2个不用的东西。（缺点：jsonp只能get，post跨域的话需要后端配合，指定域名或者所有域名都能访问）

17、有没有使用过css 预处理语言？有哪些？介绍一下基本特性和优点？

答： css 预处理有sass，less，sylus 三种预处理语言的都有一些共同特性，支持声明css变量，css常量，css函数，混淆、嵌套、引入（@import）等功能。特性和优点：既然支持常量变量和函数，那在原来需要使用js来改变css的场景就不需要大量使用js，样式列表里已经支持加减乘除等其它运算。可以定义全局css块变量，全局字体样式变量。比如主题颜色的切换。大部分内容的标题、内容样式的统一修改。css的嵌套让css代码更简洁更具有层级性更方便维护。

CSS

Css内的内容我就直接放问题啦，这里的内容都是老生常谈的内容了。

1、Css 盒子模型 ；

2、定位有哪些，特点；

3、实现一个垂直居中；（定位， css3 transform , 弹性等）

4、Px 、rem、em 特点；

5、一些不常见的属性如vertical-align基线等问题；

6、IE和W3C标准下的box-sizing 的差别 ；

7、@import 特点 ；

8、清除浮动的方式；

9、Css伪类的内容；

10、Css3 的一些内容，过渡动画等；


vue几种主动刷新
window.location.reload()
this.$router.go(0)
this.$forceUpdate();//并不管用

```

## 基础

```

```

### 数值转换

```
[] 转为字符串是 ""       // String([]) 返回""
[] 转为数字是 0            // Number([]) 返回0
[] 转为布尔值是 true        // Boolean([]) 返回true
true 转为数字是 1       // Number(true) 返回1
false 转为数字是 0      // Number(false) 返回0

[] == 0      //返回结果是 true
![] == 0     //返回结果是 true
[] == ''     //返回结果是 true
!![] == ''   //返回结果是 false
'' == true   //返回结果是 false
```



### 敏捷开发

```
1.什么是敏捷开发（What）
1.1 敏捷开发是一种价值观与原则
敏捷开发是一种价值观与原则，指导我们更加高效的开发
1.2 敏捷开发以用户需求为核心
敏捷开发以用户需求为核心，采用迭代(时间周期)、增量(循序渐进，功能模块)
的方式开发软件，目的在于快速覆盖、响应市场需求
1.3 大项目划分为小项目
大项目划分为小项目，分别完成，独立运行，如微服务的开发过程，就是将系统独立进行开发。
1.4 敏捷开发特征
1.4.1 迭代式开发 （主体是时间周期）
项目按照时间周期进行迭代，比如A功能优先级比较高，则在第一个迭代周期
内优先开发A功能，并上线。第二个迭代周期开发B功能。
1.4.2 增量交付 （主体是功能模块）

瀑布式开发模型：需求评审、概要设计、详细设计、开发、单元测试、
集成测试、上线。如微软的Vista系统，从1997年立项到2005年才问世，但是用
户反馈并不好，Vista操作系统的开发就是采用瀑布模型。

增量式开发:则代表产品是在每个周期结束时被逐步交付使用的。如微软在吸取Vista操作系统采用传统的瀑布式开发流程之后，发现操作系统并不能完全覆盖用户的需求。在2005-2007两年时间内 通过内部推行的敏捷开发原则，上线了win7，获得市场的一致好评。

1.4.3 开发团队和用户反馈推动产品开发

敏捷开发提倡用户参与到产品或项目开发的整个流程当中，通过用户反馈使得
产品更加符合用户频繁变动的需求。
1.4.4 持续集成

采用敏捷开发的产品在产品初期会上线基本功能，之后的功能是根据收集到的
用户反馈进行开发的，实现功能模块的持续集成。
1.4.5 开发团队自我管理

传统的开发模式，注重文档约束，而敏捷开发原则的推行原则要求团队内部交
流便利、文化相对开发，除去必要的文档约束，如Api接口文档，最注重的是团
队成员的高效交流，以此来提高产品、项目的开发效率、开发质量。



```

#### 敏捷开发原则

```
归结起来，就是三点：

管好你的需求；
使用统一的工具；
可视化！可视化！可视化！
我们以码云（不是那个有钱的那个马云，是“码云”）为例，来介绍一个实现敏捷开发的工具必不可少的功能：

任务管理
文档管理
代码库管理




敏捷开发原则
1.5.1 快速迭代

小版本更新发布，更快覆盖当前 市场、用户 需求。
1.5.2 需求评审

需求评审阶段，要求PM、所有相关开发人员参与到需求评审当中
需求评审阶段：
需求可行性分析、
确定需求功能范围、
PM对需求中存在异议的细节进行解释。
1.5.3 编写story、验收标准

PM 编写story、验收标准
1.5.4 多沟通

PM、开发人员之间需要多沟通、减少不必要的文档。
1.5.5 做好原型

需求评审完毕后，PM与UE UI 人员进行紧密沟通，完成指导开发人员开发的UE、UI
1.5.6 及早考虑测试

测试人员在这个阶段需要根据需求中划分的功能点，设计测试用例。

```

#### 2.为什么使用敏捷开发（Why）

```
2.1 覆盖快速变化的市场、用户需求，快速响应变化需求
在用户需求不断变化的情况下能够保证软件开发质量，把大的时间点变成小的
时间点。
2.2 把团队中职责定义清楚，发挥最大效率
```

#### 3.如何推行敏捷开发 (How)

![img](https://upload-images.jianshu.io/upload_images/2836699-8869254f2a50b7d0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



功能迭代时间大致为两周一个版本。

#### 4.采用敏捷开发的产品开发效果

> 敏捷开发大大提高了我们部门的开发效率，开发人员各自关注自己负责的功能模块，并且通过高效的沟通，在保证产品质量的前提下，实现了产品的快速迭代！



### DOM

```
DOM树扩展
根据W3C的定义，DOM树结点的属性包括标记名(nodeName)、结点类型(node Type，取值为TagTxt)、结点内容(data)、父结点对象集合(parent Node)、子结点对象集合(firstChild，lastChild)、兄弟结点对象集合(previous Sibling，nextSibling)等。DOM树结点的这些属性给出了页面的基本内容和结构信息，但不能反映标签、属性以及内容等与主题的相关程度，因而缺乏主题提取所需的语义。对DOM树扩展的总体思路为:考虑HTML页面标签的类别，以及标签属性值对页面主题信息的影响，将这种影响纳入对页面内容要素的计算中，对DOM树结点进行语义扩展，同时引入结点影响度因子来刻画该结点在树中的重要程度。
DOM树结点语义扩展
为了增加DOM树结点与页面主题信息相关程度的语义信息，计算结点内容的重要度，将HTML标签的类别(Category)、非链接文字数(WordNum)、超链接数(LinkNum)、属性集(Attibution)和影响度因子(Influence)等属性添加到结点中，扩展其语义。HTML标签依据其作用可分为5类:
描述标题及页面概要信息的标签:如〈title〉、〈meta〉等。
规划网页布局的标签:如〈table〉、〈tr〉、〈td〉、〈p〉、〈div〉等，其作用是描述网页内容的布局结构。
描述显示特点的标签:如〈b〉、〈I〉、〈strong〉、〈h1〉-〈h6〉等，其作用是强调重点内容，引起人们注意。
超链接相关的标签，表示网页间的内容相关性信息。
其他标签，如设置图像的标签〈img〉，在文本提取时将忽略这类标签。
根据HTML标签在刻画网页特征时的语义功能，将DOM树结点分为6种类别:标题类(TITLE)、正文类(CONTENT)、视觉类(VISION)、分块类(BLOCK)、超链类(LINK)和其他类(OTHER)，不同类的结点对Web信息提取的重要度不同。
标题类(TITLE):指HTML文档中标题标签的专有类别。
正文类(CONTENT):指包含网页正文内容的标签类别，如包含文字的〈td〉标签。
视觉类(VISION):指描述页面显示特性的标签类别，如〈b〉、〈strong〉等。
分块类(BLOCK):指用于网页内容分块的标签类别，如〈table〉、〈tr〉等。
超链类(LINK):指包含超链接的标签类别，如〈a〉。
其他类(OTHER):指不属于以上5种类别的标签类型。
```

### OOP

```
Object Oriented Programming，原来就是面向对象的编程啊，还有OOD（面向对象的设计），OOA（面向对象的分析）。那什么是面向对象呢？要想了解这个问题我们要先了解面向过程，这样对比我们就好理解了。

面向对象的三大特性：
1、封装
隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
2、继承
提高代码复用性；继承是多态的前提。
3、多态
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。

五大基本原则：
1、单一职责原则SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。
2、开放封闭原则OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
3、里式替换原则LSP(the Liskov Substitution Principle LSP)
子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
4、依赖倒置原则DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。
5、接口分离原则ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。

```



### 协议

#### TCP/IP协议与Http协议的区别

```
TCP/IP协议与Http协议的区别TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。

      关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

　　术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 
　　
　　
    你应该能理解，TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。
    
    
    HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。
　　下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI模型中的位置：
　　
　　



```

![img](https://img2018.cnblogs.com/blog/535842/201907/535842-20190720161008261-1479276123.png)

#### tcp

```
TCP连接

      手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。

      建立起一个TCP连接需要经过“三次握手”：

      第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

      第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

      第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

      握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）
```



#### http

```
tcp/ip
w3c标准


HTTP协议
HTTP是单向的，客户端发送请求，服务器发送响应。举例来说，当客户端向服务器发送请求时，该请求以HTTP或HTTPS的形式发送，在接收到请求后，服务器会将响应发送给客户端。每个请求都与一个对应的响应相关联，在发送响应后客户端与服务器的连接会被关闭。每个HTTP或HTTPS请求每次都会新建与服务器的连接，并且在获得响应后，连接将自行终止。 HTTP是在TCP之上运行的无状态协议，TCP是一种面向连接的协议，它使用三向握手方法保证数据包传输的传递并重新传输丢失的数据包。

HTTP可以运行在任何可靠的面向连接的协议（例如TCP，SCTP）的上层。当客户端将HTTP请求发送到服务器时，客户端和服务器之间将打开TCP连接，并且在收到响应后，TCP连接将终止，每个HTTP请求都会建立单独的TCP连接到服务器，例如如果客户端向服务器发送10个请求，则将打开10个单独的HTTP连接。并在获得响应后关闭。

理解上面这段关于 HTTP的描述时我觉得还要了解一下HTTP长连接的概念，以及HTTP与TCP的关系，简单概括一下就是：

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。
每个HTTP连接完成后，其对应的TCP连接并不是每次都会关闭。从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这个头部字段：Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache，Nginx，Nginx中这个默认时间是 75s）中设定这个时间。实现长连接要客户端和服务端都支持长连接。
HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。
HTTP消息信息是用ASCII编码的，每个HTTP请求消息均包含HTTP协议版本（HTTP/1.1，HTTP/2），HTTP方法（GET/POST等），HTTP标头（Content-Type，Content-Length），主机信息等。以及包含要传输到服务器的实际消息的正文（请求主体）。HTTP标头的大小从200字节到2KB不等，HTTP标头的常见大小是700-800字节。当Web应用程序在客户端使用更多cookie和其他工具扩展代理的存储功能时，它将减少HTTP标头的荷载。


1、HTTP协议的几个重要概念
  1.连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。
  2.消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。
  3.请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号
  4.响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。
  5.资源(Resource)：由URI标识的网络数据对象或服务。
  6.实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。
  7.客户机(Client)：一个为发送请求目的而建立连接的应用程序。
  8.用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。
  9.服务器(Server)：一个接受连接并对请求返回信息的应用程序。
  10.源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。
  11.代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。
 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。
  12.网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。
 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。
  13.通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。
  14.缓存(Cache)：反应信息的局域存储。

 

 2.发送请求
   打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。
   HTTP/1.0 请求消息的格式为：
   请求消息=请求行(通用信息|请求头|实体头)CRLF[实体内容]
   请求 行=方法 请求URL HTTP版本号 CRLF
   方 法=GET|HEAD|POST|扩展方法
   U R L=协议名称+宿主名+目录与文件名
   请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下：
   对象 GET的结果
   文件 文件的内容
   程序 该程序的执行结果
   数据库查询 查询结果
   HEAD??要求服务器查找某对象的元信息，而不是对象本身。
   POST??从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。
   一个请求的例子为：
     GEThttp://networking.zju.edu.cn/zju/index.htmHTTP/1.0 networking.zju.edu.cn/zju/index.htmHTTP/1.0 头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答。
   请求头??告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。
   实体头??实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。
   实体??请求或应答对象本身。
 

3.发送响应
  服务器在处理完客户的请求之后，要向客户机发送响应消息。
  HTTP/1.0的响应消息格式如下：
  响应消息=状态行(通用信息头|响应头|实体头) CRLF 〔实体内容〕
  状态行=HTTP版本号 状态码 原因叙述
  状态码表示响应类型
  1×× 保留
  2×× 表示请求成功地接收
  3×× 为完成请求客户需进一步细化请求
  4×× 客户错误
  5×× 服务器错误
  响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。
 

4.关闭连接
 客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话

```

#### websocket

```
WebSocket协议
WebSocket是双向的，在客户端-服务器通信的场景中使用的全双工协议，与HTTP不同，它以ws://或wss://开头。它是一个有状态协议，这意味着客户端和服务器之间的连接将保持活动状态，直到被任何一方（客户端或服务器）终止。在通过客户端和服务器中的任何一方关闭连接之后，连接将从两端终止。

让我们以客户端-服务器通信为例，每当我们启动客户端和服务器之间的连接时，客户端-服务器进行握手随后创建一个新的连接，该连接将保持活动状态，直到被他们中的任何一方终止。建立连接并保持活动状态后，客户端和服务器将使用相同的连接通道进行通信，直到连接终止。

新建的连接被称为WebSocket。一旦通信链接建立和连接打开后，消息交换将以双向模式进行，客户端-服务器之间的连接会持续存在。如果其中任何一方（客户端服务器）宕掉或主动关闭连接，则双方均将关闭连接。套接字的工作方式与HTTP的工作方式略有不同，状态代码101表示WebSocket中的交换协议。
```

#### WebSocket，它与HTTP有何不同

```
何时使用WebSocket
即时Web应用程序：即时Web应用程序使用一个Web套接字在客户端显示数据，这些数据由后端服务器连续发送。在WebSocket中，数据被连续推送/传输到已经打开的同一连接中，这就是为什么WebSocket更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。
游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在WebSocket游戏应用程序中非常有帮助。
聊天应用程序：聊天应用程序仅使用WebSocket建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的WebSocket连接，用于发送和接收消息以及一对一的消息传输。

不能使用WebSocket的场景
如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用WebSocket。如果我们要获取旧数据，或者只想获取一次数据供应用程序使用，则应该使用HTTP协议，不需要很频繁或仅获取一次的数据可以通过简单的HTTP请求查询，因此在这种情况下最好不要使用WebSocket。

注意：如果仅加载一次数据，则RESTful Web服务足以从服务器获取数据。
```

![img](https://pic3.zhimg.com/80/v2-7473ab83669c31a09c2b2814c7f48fca_1440w.jpg)

### css

```
目前最主流的 CSS 预处理器：Sass、LESS、Stylus 。
    优缺点
    优点：语言级逻辑处理，动态特性，改善项目结构
    缺点：采用特殊语法，框架耦合度高，复杂度高

    后处理器：Rework 、PostCSS、
    优缺点
    优点：使用 CSS 语法，容易进行模块化，贴近 CSS 的未来标准
    缺点：逻辑处理能力有限.

```

#### 换行

```
加一条css实现强制不换行/自动换行/强制换行 强制不换行 div{ white-space:nowrap; } 自动换行 div{ word-wrap: break-word; word-break: normal; } 强制英文单词断行 div{ word-break:break-all; }
```



#### 预处理

##### postcss

```
什么是postcss
postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如：

1 . 使用下一代css语法

2 . 自动补全浏览器前缀

3 . 自动把px代为转换成rem

4 . css 代码压缩等等

postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。

与 less sass 的区别
less sass 是预处理器，用来支持扩充css语法。

postcss 既不是 预处理器也不是 后处理器，其功能比较广泛，而且重要的一点是，postcss可以和less/sass结合使用

作者：指尖跳动
链接：https://www.jianshu.com/p/9a9048bc8978
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### css3新特性

```
CSS3有哪些新特性？
新增选择器 p:nth-child（n）{color: rgba（255, 0, 0, 0.75）}

弹性盒模型 display: flex;

多列布局 column-count: 5;

媒体查询 @media （max-width: 480px） {.box: {column-count: 1;}}

个性化字体 @font-face{font-family:BorderWeb;src:url（BORDERW0.eot）；}

颜色透明度 color: rgba（255, 0, 0, 0.75）；

圆角 border-radius: 5px;

渐变 background:linear-gradient（red, green, blue）；

阴影 box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；

倒影 box-reflect: below 2px;

文字装饰 text-stroke-color: red;

文字溢出 text-overflow:ellipsis;

背景效果 background-size: 100px 100px;

边框效果 border-image:url（bt_blue.png） 0 10;

转换
旋转 transform: rotate（20deg）；

倾斜 transform: skew（150deg, -10deg）；

位移 transform:translate（20px, 20px）；

缩放 transform: scale（。5）；

平滑过渡 transition: all .3s ease-in .1s;

动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;

以上就是CSS3有哪些新特性？CSS3新特性详解的详细内容。每日都会更新哦，关注我！！
```



### CSS 盒子模型(Box Model)

```
Margin(外边距) - 清除边框外的区域，外边距是透明的。
Border(边框) - 围绕在内边距和内容外的边框。
Padding(内边距) - 清除内容周围的区域，内边距是透明的。
Content(内容) - 盒子的内容，显示文本和图像。
div {
    width: 300px;
    border: 25px solid green;
    padding: 25px;
    margin: 25px;
}
```

![img](https://upload-images.jianshu.io/upload_images/3087126-da0346440f717e4c.png?imageMogr2/auto-orient/strip|imageView2/2/w/596/format/webp)

```
那应该选择哪中盒子模型呢？

当然是“标准 W3C 盒子模型”了。就是在网页的顶部加上 DOCTYPE 声明，所有浏览器都会采用标准 W3C 盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。

NOTE：如果不加 DOCTYPE 声明，那么各个浏览器会根据自己的行为去理解网页，即 IE 浏览器会采用 IE 盒子模型去解释你的盒子，而 FF 会采用标准 W3C 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。

```



### id 和 class 选择器

```
#para1
{
    text-align:center;
    color:red;
}
.center {text-align:center;}
也可以指定特定的HTML元素使用class。

p.center {text-align:center;}

```

### CSS/CSS3 实现 居中（水平&垂直）

```
1，水平居中：行内元素

把行内元素放在一个属性块（display：block）元素中，然后设置父层元素属性居中：

.test {

text-align:center;
}

2，水平居中：块状元素

设置外边距

.test {

margin: 100px auto;
}

3，水平居中：多个块状元素

把块状元素属性（display：inline-block），然后设置父层元素属性居中：

.test {

text-align:center;
}

4，水平居中：多个块状元素（flexbox布局实现）

把块状元素的父元素属性 display:flex和justify-content:center，如下设置：

.test {

text-align:center;
}

5，垂直居中：单行的行内元素

设置height和line-height属性

.test {

height: 100px;
line-height:100px; 
}

6，垂直居中：多行的行内元素

给要居中的父元素设置display:table-cell和vertical-align:middle属性

.test {

background: red;
width: 200px;
height: 200px;
/* 以下属性垂直居中 */
display: table-cell;
vertical-align:middle;
}

7，垂直居中：已知高度的块状元素

给要居中的元素设置如下属性

.test {

top: 50%;
margin-top: -50px;  /* margin-top值为自身高度的一半 */
position: absolute;
padding:0;
}

8，水平垂直居中：已知高度和宽度的元素

给要居中的元素设置如下属性

（1）
.test {

position: absolute;
margin:auto;
left:0;
top:0;
right:0;
bottom:0;
}
（2）
.test{

position: absolute;
top: 50%;
left: 50%;
margin-top: -75px;  /* 设置margin-left / margin-top 为自身高度的一半 */
margin-left: -75px;
}

9，水平垂直居中：未知高度和宽度元素

给要居中的元素设置如下属性

.test {

position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);  /* 使用css3的transform来实现 */
}

10，水平垂直居中：可用flex

设置如下属性

.test {

 display: flex;
justify-content:center;
align-items: center;
/* 注意这里需要设置高度来查看垂直居中效果 */
background: #AAA;
height: 300px;
}
```



### 响应式 Web 设计

```
设置 Viewport
一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：

<meta name="viewport" content="width=device-width, initial-scale=1.0">
width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。

height：和 width 相对应，指定高度。
initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。
maximum-scale：允许用户缩放到的最大比例。
minimum-scale：允许用户缩放到的最小比例。
user-scalable：用户是否可以手动缩放。
```

#### 网格视图

```
创建响应式网格视图
接下来我们来创建一个响应式网格视图。

首先确保所有的 HTML 元素都有 box-sizing 属性且设置为 border-box。

确保边距和边框包含在元素的宽度和高度间。

添加如下代码：

* {
    box-sizing: border-box;
}
```



### 适配

```
pc兼容 浏览器特性，设计模式，模块化
网页性能优化，webpack less sass，ts，es6，手机端pc端适配

PC端与移动端适配方案
最近有个将 PC 端项目迁移到移动端的需求。我就查了查 PC 端和移动端同时适配的方式。一共两种：通过 @media 来适配不同的 css 样式；又或者通过判断当前设备来重定向到不同的页面。
我试了一下 QQ 首页和 Teambition，都是通过重定向到不同端的页面来实现的。的确，如果真的要适配好两个端，对于复杂的项目还是得写两套 UI 来做到完美适配。

@media only screen
and (min-device-width : 768px){
   .PaperTitle{
       padding: 0 8rem;
   }
}
@media only screen
and (max-device-width : 768px) {
    .PaperTitle{
    padding: 0 3rem;
    }
}
==============================
<script type="text/javascript">
   var os = function () {
       var ua = navigator.userAgent,
       isWindowsPhone = /(?:Windows Phone)/.test(ua),
       isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone,
       isAndroid = /(?:Android)/.test(ua),
       isFireFox = /(?:Firefox)/.test(ua),
       isChrome = /(?:Chrome|CriOS)/.test(ua),
       isTablet = /(?:iPad|PlayBook)/.test(ua) || (isAndroid &&       !/(?:Mobile)/.test(ua)) || (isFireFox && /(?:Tablet)/.test(ua)),
       isPhone = /(?:iPhone)/.test(ua) && !isTablet,
       isPc = !isPhone && !isAndroid && !isSymbian;

       return {
              isTablet: isTablet,
              isPhone: isPhone,
              isAndroid: isAndroid,
              isPc: isPc
       };
   }();
   if(os.isPc){
      location.replace("http://www.onlymid.com.cn/");
   }

   if (os.isAndroid || os.isPhone) {
      location.replace('http://www.onlymid.com.cn/html/2016shujia/wap/');
   } else if (os.isTablet) {
      location.replace('http://www.onlymid.com.cn/html/2016shujia/wap/');
   }
</script>

1. 首先最重要的，在html代码头部加上一段代码：
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
简单解释下，viewport 表示用户网页的可视区域，简称视图或窗口。
width：控制视图的大小， device-width 表示和设备屏幕同大小。
initial-scale：网页初始缩放比例,1.0表示占屏幕100%的面积。
maximum-scale：允许用户缩放到的最大比例。
minimum-scale：允许用户缩放到的最小比例。
user-scalable：是否允许手动缩放。

2. 图片的自适应
这个比较简单，在css中加入一行代码： img { max-width: 100%;}

3. 文字以及像素绘制的图案的自适应
这部分主要通过单位来控制，介绍几个比较常用的单位：

px pixel的缩写，中文是像素。比如电脑像素(或者说分辨率)是1920x1080的，就是指水平方向是1920个像素点，垂直方向是1080个像素点。px缺点很明显，就是固定值，无法跟着屏幕分辨率等比的变化。

em 表示相对尺寸，em可以较好的适应屏幕尺寸变化，em和px不同，em在一个屏幕中不是固定的值，他继承于父级元素的尺寸。

% 就是百分比，也是继承于父级元素。

vw view width的缩写，表示视图的宽度。也就是能根据浏览器的高度宽度自动调整，1vw等于视图宽度的1%，同理vh 是view height的缩写，表示视图的高度。并且vw 和 vh 都是不包含页面滚动条的。

比较推荐使用的是 % 和 vw ，都能很好地用来做自适应的开发。

移动端
其实，移动端的自适应高度和宽度要更简单，就是要加入一行viewport标签

<!DOCTYPE html>
<html>
<head>
　　<meta charset="utf-8">
　　<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
　　<meta content="yes" name="apple-mobile-web-app-capable">
　　<meta content="black" name="apple-mobile-web-app-status-bar-style">
　　<meta content="telephone=no" name="format-detection">
　　<meta content="email=no" name="format-detection">
　　<title>标题</title>
　　<link rel="stylesheet" href="index.css">
</head>
<body> 这里开始内容 </body>
</html>

如上面的meta viewport模板所示，首先，在网页代码的头部，加入一行viewport标签：

<meta name=”viewport” content=”width=device-width, initial-scale=1″ />

viewport，是网页默认的宽度和高度。

该行代码表示，网页的宽度默认等于设备屏幕的宽度，原始缩放比例为1，即网页初始大小占屏幕面积的100%

1：由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。具体说，CSS代码不能指定像素宽度：width:xxx px；可指定百分比宽度：width: xx%；或者width:auto；

2：字体大小一般使用em，尽量少使用px

3：尽量使用流动布局

4：①自适应网页设计的核心，就是CSS3的引入的media query，多媒体查询模块，会自动探测屏幕宽度，然后加载相应的CSS文件

示例：<link rel="stylesheet" type="text/css"  media="screen and (max-device-width: 400px)" href="style.css" />，当屏幕小于400时，就加载style.css这个文件 

5：②除了使用html标签加载CSS文件，还可以在现有CSS文件中加载

示例：@import url("style2.css") screen and (max-device-width: 800px)，当小于800px屏幕时，就加载style2.css文件

6：🌂除了使用html标签和css文件加载css文件，还可以直接在css通过@media来添加css样式代码

示例：@media screen and (max-width: 960px){　　body{background: #000;　　}

7：图片的自动缩放，比较简单。只需要一行CSS代码：

img{ max-width: 100%;}，建议根据不同的屏幕分辨率，加载不同大小像素的图片
```

### px、em、rem区别介绍

```
PX
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

PX特点

1. IE无法调整那些使用px作为单位的字体大小；
2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；
3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。
EM
em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。

EM特点

1. em的值并不是固定的；
2. em会继承父级元素的字体大小。
注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。

所以我们在写CSS的时候，需要注意两点：

1. body选择器中声明Font-size=62.5%；
2. 将你的原来的px数值除以10，然后换上em作为单位；
3. 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。
也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。

REM
rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素

。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，

又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子：

p {font-size:14px; font-size:.875rem;}
注意： 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。

px 与 rem 的选择？
对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。

对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。
```



### 前端模块化，组件化，工程化

```
1.前端模块化：

可以理解为一组自定义业务的抽象封装，是根据项目的情况来进行封装组合到一起的，比如我们可以分为登录模块，评论模块。模块可维护性好，组合灵活，方便调用，多人协作互不干扰。


那具体什么是模块化呢,还是举简单的例子,我们要写一个实现A功能的JS代码,这个功能在项目其他位置也需要用到,那么我们就可以把这个功能看成一个模块采用一定的方式进行模块化编写,既能实现复用还可以分而治之,同理在写样式的时候,如果我们需要某种特殊的样式,会在很多地方应用,那么我们也可以采用一定的方式进行CSS的模块化,具体说来,JS模块化方案很多有AMD/CommonJS/UMD/ES6 Module等,CSS模块化开发大多是在less、sass、stylus等预处理器的import/mixin特性支持下实现的,具体技术大家自行学习。



2.前端组件化：

指对具体的某个功能的封装，比如所有的分页可以封装为分页组件来统一使用，以此来达到组件复用，提高开发效率。

3.前段工程化：

概念：指使用软件工程的技术和方法来进行前端项目的开发、维护和管理。

前端工程化包含如下：
1.代码规范: 保证团队所有成员以同样的规范开发代码。
2.分支管理: 不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。
3.模块管理: 一方面，团队引用的模块应该是规范的;另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。（以上两点可以总结为模块化或者组件化开发。）
4.自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。
5.构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源，
6.部署。 将构建好的代码部署到生产环境。

前面我们提到在组织代码的时候会用到模块化和组件化,大家应该理解到,前端工程化是一个高层次的思想,而模块化和组件化是为工程化思想下相对较具体的开发方式,因此可以简单的认为模块化和组件化是工程化的表现形式。






```



### vue\react/angular的区别

```


Vue 使用的是 web 开发者更熟悉的模板与特性，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。React 的特色在于函数式编程的理念和丰富的技术选型。Vue 比起 React 更容易被前端工程师接受，这是一个直观的感受；React 则更容易吸引在 FP 上持续走下去的开发者。从使用习惯和思维模式上考虑，对于一个没有任何Vue和React基础的web开发者来说， Vue会更友好，更符合他的思维模式。React对于拥有函数式编程背景的开发者以及一些并不是以web为主要开发平台的开发人员而言，React更容易接受。这并不意味着他们不能接受Vue，Vue和React之间的差异对他们来说就没有web开发者那么明显。可以说，Vue更加注重web开发者的习惯。实现上，Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为Push-based和Pull-based。所谓Push-based就是说，改动数据之后，数据本身会把这个改动推送出去，告知渲染系统自动进行渲染。在React里面，它是一个Pull的形式，用户要给系统一个明确的信号说明现在需要重新渲染了，这个系统才会重新渲染。两者并没有绝对的优劣之分，更多的也是思维模式和开发习惯的不同。

React 和 Vue 有许多相似之处，它们都有：

使用 Virtual DOM
提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。
由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要承认 React 比 Vue 更好的地方，比如更丰富的生态系统。

使用 JSX 的渲染函数有下面这些优势：

你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。

开发工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的 (比如，linting、类型检查、编辑器的自动完成)。


AngularJS (Angular 1)
Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。

数据绑定
AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。

指令与组件
在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。在 AngularJS 中，每件事都由指令来做，而组件只是一种特殊的指令。

```



### git

```
毫无疑问，Git 是当今 Web 开发中版本控制的标准。对于每位前端工程师而言，了解基本的 Git 概念和工作流程是非常重要的，这样才能在各种规模的团队中高效工作。

下面是你应该知道的一些流行的 Git 命令：

git config

git init

git clone

git status

git add

git commit

git push

git pull

git branch

这些命令可以提高工作效率，熟悉它们当然是很好的；但是前端工程师还应该学习 Git 的基本概念。以下是一些适合你的资源：

“解释 Git 的基本概念以及如何使用 GitHub”（https://thepilcrow.net/explaining-basic-concepts-git-and-github/）；

“如何使用 GitHub——使用 GitHub 进行开发协作”（https://www.edureka.co/blog/how-to-use-github/）；

GitHub。
```



### 前端性能优化

![image-20220210175720546](E:\zokoko\相关\tips\mdTips\mdImage\image-20220210175720546.png)

```
阻塞
普通模式，JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执⾏完毕才能去做其它事情。一般将此类js放在在<body>标签的底部，减少对整个页面下载的影响
<script src="index.js"></script>
async 模式：JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会⽴即执⾏。
<script async src="index.js"></script>
defer 模式：JS 的加载是异步的，执⾏是被推迟的。等整个⽂档解析完成DOMContentLoaded 事件即将被触发时，被标记了defer 的 JS ⽂件才会开始依次执⾏
<script defer src="index.js"></script>




1. 减少 HTTP 请求
一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP 

3. 使用服务端渲染
优点：首屏渲染快，SEO 好。
缺点：配置麻烦，增加了服务器的计算压力。
客户端渲染过程
访问客户端渲染的网站。
服务器返回一个包含了引入资源语句和 <div id="app"></div> 的 HTML 文件。
客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。

这样做的好处是什么？是更快的内容到达时间 (time-to-content)。

假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。

这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因

4. 静态资源使用 CDN

如果用户访问的网站部署了 CDN，过程是这样的：

浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
浏览器再根据 SLB 发回的地址重定向到缓存服务器。
如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

5. 将 CSS 放在文件头部，JavaScript 文件放在底部
CSS 执行会阻塞渲染，阻止 JS 执行
JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建
如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。

那为什么 CSS 文件还要放在头部呢？

因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。

另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。

6. 使用字体图标 iconfont 代替图片图标
字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。

压缩字体文件

7. 善用缓存，不重复加载相同的资源
为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。

不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？

可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。

具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。

8. 压缩文件
压缩文件可以减少文件下载时间，让用户体验性更好。

得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。

在 webpack 可以使用如下插件进行压缩：

JavaScript：UglifyPlugin
CSS ：MiniCssExtractPlugin
HTML：HtmlWebpackPlugin
其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。

gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。

附上 webpack 和 node 配置 gzip 的使用方法。

附上 webpack 和 node 配置 gzip 的使用方法。

下载插件

npm install compression-webpack-plugin --save-dev
npm install compression
webpack 配置

const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [new CompressionPlugin()],
}
node 配置

const compression = require('compression')
// 在其他中间件前使用
app.use(compression())

(1). 图片延迟加载
在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

首先可以将图片这样设置，在页面不可见时图片不会加载：

<img data-src="https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4">
等页面可见时，使用 JS 加载图片：

const img = document.querySelector('img')
img.src = img.dataset.src

(2). 响应式图片
响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。

通过 picture 实现

<picture>
    <source srcset="banner_w1000.jpg" media="(min-width: 801px)">
    <source srcset="banner_w800.jpg" media="(max-width: 800px)">
    <img src="banner_w800.jpg" alt="">
</picture>
通过 @media 实现

@media (min-width: 769px) {
    .bg {
        background-image: url(bg1080.jpg);
    }
}
@media (max-width: 768px) {
    .bg {
        background-image: url(bg768.jpg);
    }
}

10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。
根据文件内容生成文件名，结合 import 动态引入组件实现按需加载
通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。

11. 减少重绘重排
浏览器渲染过程

解析HTML生成DOM树。
解析CSS生成CSSOM规则树。
将DOM树与CSSOM规则树合并在一起生成渲染树。
遍历渲染树开始布局，计算每个节点的位置大小信息。
将渲染树每个节点绘制到屏幕。
如何减少重排重绘？

用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。
如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。

12. 使用事件委托
事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

13. 注意程序的局部性
一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。

局部性通常有两种不同的形式：

时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。
空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。
时间局部性示例

function sum(arry) {
    let i, sum = 0
    let len = arry.length

    for (i = 0; i < len; i++) {
        sum += arry[i]
    }

    return sum
}
在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性

空间局部性示例

具有良好空间局部性的程序

// 二维数组 
function sum1(arry, rows, cols) {
    let i, j, sum = 0

    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            sum += arry[i][j]
        }
    }
    return sum
}

14. if-else 对比 switch
当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。


15. 查找表
当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建

可以将这个 switch 语句转换为查找表

const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11]

return results[index]
如果条件语句不是数值而是字符串，可以用对象来建立查找表

const map = {
  red: result0,
  green: result1,
}

return map[color]


16. 避免页面卡顿
60fps 与设备刷新率

目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。
其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。
在这里插入图片描述

假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。

对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。

for (let i = 0, len = arry.length; i < len; i++) {
    process(arry[i])
}
假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。

const todo = arry.concat()
setTimeout(function() {
    process(todo.shift())
    if (todo.length) {
        setTimeout(arguments.callee, 25)
    } else {
        callback(arry)
    }
}, 25)

17. 使用 requestAnimationFrame 来实现视觉变化
从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame

18. 使用 Web Workers
Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。

Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。

创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：

var myWorker = new Worker('worker.js');
// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。
first.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}

second.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}

在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：

onmessage = function(e) {
  console.log('Message received from main script');
  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
  console.log('Posting message back to main script');
  postMessage(workerResult);
}


21. 降低 CSS 选择器的复杂性
(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。
看个示例

#block .text p {
    color: red;
}
查找所有 P 元素。
查找结果 1 中的元素是否有类名为 text 的父元素
查找结果 2 中的元素是否有 id 为 block 的父元素
(2). CSS 选择器优先级
内联 > ID选择器 > 类选择器 > 标签选择器

不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。

各浏览器兼容性：

Chrome 29+
Firefox 28+
Internet Explorer 11
Opera 17+
Safari 6.1+ (prefixed with -webkit-)
Android 4.4+
iOS 7.1+ (prefixed with -webkit-)

```

#### 纯净代码

```
纯净代码

能够编写干净的代码是一项很棒的技能，许多组织都对此提出了很高的要求。如果你想从开发人员的职位升级为高级开发人员，则应该好好学习纯净代码的理念。

简洁的代码应该是优雅且易读的。它们应该专注于某个目标，你应该做到这一点。所有测试均运行在纯净代码中。它们不应包含重复项，应尽量减少实体（例如类、方法和函数）的使用。

想要编写纯净代码，开发人员应做的一些事情是：

为变量、类、方法和函数创建有意义的名称；

函数应该很小并且应该尽可能减少参数；

根本不需要注释——代码本身就应该说明一切。

如果你想了解有关纯净代码检查的更多信息，请阅读 Robert C. Martin 的书籍和帖子。
```



#### 节流和防抖

```
节流和防抖
日常开发过程中，滚动事件做复杂计算频繁调用回调函数很可能会造成页面的卡顿，这时候我们更希望把多次计算合并成一次，只操作一个精确点，JS把这种方式称为debounce（防抖）和throttle（节流）

函数节流

当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行实现函数节流我们主要有两种方法：时间戳和定时器

var throttle = function(func, delay) {var prev = Date.now(); return function() { var context = this; //this指向window var args = arguments; var now = Date.now(); if (now - prev >= delay) { func.apply(context, args); prev = Date.now(); } }}function handle() { console.log(Math.random());}window.addEventListener('scroll', throttle(handle, 1000));

这个节流函数利用时间戳让第一次滚动事件执行一次回调函数，此后每隔1000ms执行一次，在小于1000ms这段时间内的滚动是不执行的

09
函数防抖
当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。

function debounce(fn, wait) {var timeout = null; //定义一个定时器 return function() { if(timeout !== null) clearTimeout(timeout); //清除这个定时器 timeout = setTimeout(fn, wait); }}// 处理函数function handle() { console.log(Math.random()); }// 滚动事件window.addEventListener('scroll', debounce(handle, 1000));

如上所见，当持续触发scroll函数，handle函数只会在1秒时间内执行一次，在滚动过程中并没有持续执行，有效减少了性能的损耗。

防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象。


```



## 系统架构SE

```
无论怎么分，作为一个架构师，你必须具备以下几个特性。

技术能力

技术能力，不用置疑肯定是最重要的。技术能力弱的架构不是一个好架构。所以，你需要知道所有主流技术的基本原理、应用场景，及快速解决问题的能力。

所以，架构师必须要有见识，所需知识面肯定是要不断拓展的。你需要清楚在什么样的场景用什么样的技术比较合适，并知道可能存在什么样的风险。来了需求，你脑袋是空的，不知道用什么技术这是最可怕的。

架构能力

这个可以表现为抽象能力、整体规划能力、及设计能力。你需要照在业务的角度进行系统分解、技术选型、架构搭建，以及规范制定。架构出来了至少可以满足近几年的发展，或者可以很方便对现有架构进行扩容。

有人说架构不需要懂业务，我面试过的就有明确表示不做业务架构。当然有方面的架构师，如中间件架构师，运维基础设施架构师等。但一般的后端架构师都是需要了解业务，不理解业务你如果进行系统分解，服务划分，及根据不同业务作出不同的架构？

技术都是为业务服务的，不站在业务的角度设计架构，那架构就是空谈。

沟通能力

这个看起来不是最重要的，其实也非常重要。作为一个优秀的架构师，你需要清楚的知道客户的需求，需要不断和需求人员进行沟通，以达到客户真正的目的。

不论是不是架构师，任何一个职场人，提高自己的沟通表达能力无疑是不可或缺的。有一句话怎么说的，领导就喜欢拍马屁的。做领导的大多不是技术特别牛的，但沟通能力肯定是一流的。

这3点肯定是架构师的核心，但不一定是每个架构师的标准。
```

### 信息系统

```
信息系统战略规划-方法：

第一阶段：以数据处理为核心，围绕职能部门需求

企业系统规划法（BSP）：自上而下识别系统目标，自下而上设计信息系统，对组织机构的变动具有适应性

关键成功因素法（CSF）：找实现目标的关键信息集合，从而确定开发有限次序

战略集合转化法（SST）：把战略目标看成“信息集合”，把战略目标转变成信息系统的战略目标

第二阶段：以企业内部MIS为核心围绕企业整体需求

战略数据规划法（SDP）、信息工程法（IE）、战略栅格法（SG）

第三阶段：综合考虑企业内外环境，以集成为核心，围绕企业战略需求

价值链分析法（VCA）、战略一致性模型（SAM）

 

企业信息化与电子商务-->商业智能

需求分析、数据仓库建立、数据抽取、建立BI分析报表、用户培训和数据模拟测试、系统改进和完善

数据仓库、数据挖掘、OLAP

 

数据仓库的特点：面向主题、集成的、相对稳定的、反应历史变化

 

数据挖掘 方法：决策树、神经网络、遗传算法、关联规则挖掘算法 分类：关联分析、序列模式分析、分类分析、聚类分析

 

企业门户：

企业网站：注重单向信息传递，缺互动

企业信息门户：把各种应用系统。数据资源和互联网资源统一集成到企业门户之下

企业知识门户：企业网站的基础上增加知识性内容

企业应用门区：实际上是对企业业务流程的几册很难过，它以业务流程和企业应用为核心，把也去流程中功能不同的应用模块通过门户技术集成在一起

企业通用门户：鸡以上四者于一身

 

信息化的三流：信息流。资金流。物流

 

电子商务的形式：B2C、B2B、C2C、O2O（线上对线下）

 

软件开发方法：

结构化：用户至上，严格区分工作阶段，每个阶段有任务和成果，强调系统开发过程的整体性和全局性，系统开发过程工程化，文档资料标准化，自顶向下，逐步求精

原型法：适用于需求不明确的开发，包括抛弃型原型和进化型原型

面向对象方法：更好的复用，关键在于建立一个全面、合理、统一的模型，分析、设计、实现三个阶段，界限不明确

面向服务的方法：SO方法有三个主要的抽象级别，是操作、服务、业务流程，SOAD分为三个层次，是基础设计层、应用结构层、业务组织层，服务建模是分为服务发现、服务规约、服务实现

 

软件开发模型：

瀑布模型：软件计划、需求分析、软件设计、程序编码、软件测试。运行维护

演化模型：

增量模型：每一个增量均发布一个可操作的产品

螺旋模型：指定计划、风险分析、实施工程、客户评估

快速原型模型

喷泉模型：迭代，无间隙

V模型

统一过程：初始（确定项目范围和边界）、细化（建立软件架构基础）、构建（构建组装与测试）、交付（制作发布版本）

构件组装模型：需求分析和定义、软件架构设计、构件库建立、应用软件构建、测试和发布

敏捷方法：自适应开发、水晶方法、特性驱动开发、极限编程

 

逆向工程

实现级：包括程序的抽象语法书、符号表、过程的设计表示

结构级：包括反应程序分量之间项目依赖关系的信息。例如调用图、结构图、程序和数据结构

功能级：包括反应程序段功能及程序段之间关系的信息

领域级：包括反应程序分量或者程序实体与应用领域概念之间对应关系的信息

 

需求工程：软件需求是指用户对系统在功能、行为、性能、设计约束等方卖弄的期望，用户解决问题或达到目标所需的条件或能力，是系统或系统不见要满足合同。标准。规范和其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明

 

需求开发：需求获取、需求分析、需求定义、需求验证

需求管理：变更控制、版本控制、需求跟踪、需求状态跟踪

需求管理支持需求开发

 

软件需求获取方法：手机资料、联合讨论会、用户访谈、书面调查、现场观摩、参加业务实践、阅读历史文档、抽样调查

软件需求的分类：业务需求、用户需求、系统需求、功能需求、性能需求、设计约束、基本需求、期望需求、兴奋需求

 

UML

结构图：类图、对象图、包图、结合结构图、构建图、部署图、制品图

行为图：用例图、顺序图、通信图、定时图、状态图、活动图、交互图

 

4+1视图

逻辑视图（系统分析和设计人员）-->实现视图（程序员）-->部署视图（系统弄个和网络工程师）-->进程视图（系统集成人员）

用例视图（最终用户）

 

用例图：描述一组用例、参与者及它们之间的关系。用户角度描述系统功能；参与者是外部因素；用例是功能单元

关系包括：包含关系、扩展关系、泛化关系

 

用例建模流程：识别参与者、合并需求获得用例、细化用例描述、调整用例模型

 

类和对象的关系：依赖关系、泛化关系、聚合关系、组合关系、实现关系

 

人机界面设计：置于用户控制之下、减少用户记忆负担、保持界面的一致性

结构化设计：保持模块适中、尽可能减少调用的深度、多扇入，少扇出、单入口，单出口、模块的作用域应该在模块之内、功能应该是可预测的

 

面向对象设计原则：

单一职责：设计谜底单一的类

开放-封闭：对扩展开放，对修改封闭

李氏替换：子类可以替换父类

依赖倒置：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程

接口隔离：使用多个专门的接口比使用单一的总接口要好

组合重用：要尽量使用组合，而不是集成关系达到重用目的

迪米特：一个对象应当对其他对象有尽可能少的了解

 

设计模式：

架构模式：软件设计中的高层决策，例如使用C/S结构就属于架构模式，架构模式反应了开发软件系统过程中所做的基本设计决策

设计模式：主要关注软件系统的设计，预聚体的实现语言无关

惯用法：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构建与构建之间的关系。每种编程语言都有它自己特定的模式

 

设计模式分类：

创建性模式：

工厂方法（factory）--动态生成对象

抽象工厂（abstract factory）--生产系列对象

原型（prototype）-克隆对象

单例（singleton）--单实例

构建器（builder）--复杂对象构建

结构型模式：

适配器（adapter）--转换接口

桥接（bridge）--继承树拆分

组合（composite）--树形目录结构

装饰（decorator）--附加职责

外观（facade）--对外统一接口

享元（flyweight）--汉字编码

代理（proxy）--快捷方式

行为型模式：

职责链（chain of resposibility）--传递职责

命令（command）--日志记录，可撤销

解释器（interpreter）--虚拟机机制

迭代器（iterator）--数据集

中介者（mediator）--不直接引用

备忘录（memento）、观察者（observer）--联动

状态（state）--状态变成类

策略（strategy）--多方案切换

模板方法（template method）、访问者（visitor）

 

软件测试--测试类型

动态测试：黑盒测试、白盒测试、灰盒测试

静态测试：桌前审查、代码审查、代码走查

 

面向对象的测试：算法层（单元测试）、类层（模块测试）、模板层（集成测试）。系统层（系统俄式）

 

软件调试：

方法：

蛮力法：主要思想是“通过计算机找错”，低效，耗时

回溯法：从出错处人工沿控制流程往回追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施

原因排除法：主要思想是演绎和归纳，用二分法实现

调试和测试区别：

测试找出存在的错误，调试定位错误并修改错误

调试时测试后的活动

测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个位置的条件开始，结束的过程不可预计

测试过程可以事先设计，进度可以事先确定；调试不能描述过程或持续时间

 

软件架构概念：

软件架构风格是描述某一特定领域中系统组织方式的惯用模式。架构风格定义一个系统家族，即一个体系结构定义一个词汇表和一组约束。词汇表中暴行一些构建和连接类型，而这租约束支出系统是如何将这些构建和连接件组合起来的。

软件架构为软件系统提供给了一个结构、行为和属性的高级抽象，有构成系统的元素描述，这些元素的相互作用，指导元素集成的模式以及这些模式的约束组成

软件架构师项目干系人进行交流的手段，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性

软件架构使推理和控制的更改更加简单，有助于循环渐进的原型设计，可以作为培训的基础

软件架构是可传递复用的模型，通过研究软件架构可能预测软件的质量

 

软件架构建模：

结构模型：以架构的构建、连接件和其他概念来刻画结构

框架模型：不太侧重描述结构的细节而更侧重于整体的结构

动态模型：系统的”大颗粒“的行为性质

过程模型：构建系统的步骤和过程

功能模型：”由一组功能构件按层次组成，下层向上层提供服务

 

架构描述语言（ADL）：支持构建、连接子及其配置的描述语言。ADL对链接子的重视成为区分ADL和其他建模语言的重要特征之一。

ADL包括：UniCon，Rapide，Darwin，Wright，C2 SADL，Acme，xADL，XYZ/ADL，A BC/ADL等

 

软件架构风格：

数据流风格：批处理序列、管道-过滤器

调用/返回风格：主程序/子程序、面向对象、层次结构

独立构建风格：进程通信、事件驱动（隐式调用）

虚拟机风格：解释器、基于规则的系统

仓库风格：数据库系统、超文本系统、黑板系统

 

批处理序列：构建为一系列固定顺序的计算单元，构件之间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，数据必须是完整的，以整体的方式传递

管道-过滤器：每个构件都有一组输入和输出，构建读输入的数据流，经过内部处理，然后产生输出数据流。早期的编译器就是采用这种架构。要一步一步处理的，均可采用此架构风格

 

主程序/子程序：单线程控制，把问题划分为若干个处理步骤，构建即为主程序和子程序，子程序通常可合并成为模块。通过调用作为交互机制，即充当连接件的角色。调用关系具有层次性，其语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性

面向对象：构件是对象，对象是抽象数据类型的实例。在抽象数据类型中，数据的表示和它们的相应操作被封装起来，对象的行为体香在其接受和请求的动作。连接件即是对象间交互的方式，对象是通过函数和过程的调用来交互的

层次结构：构件组织成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己领接的层。通过层次结构，可以将大的问题分解为若干个渐进的小问题逐步解决，可以隐藏问题的复杂度。修改某一层，最多影响其相邻的两层

 

层次结构的的优点：

这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现

不同的层次处于不同上午抽象级别：越靠近底层，抽象级别越高；越靠近顶层，抽象级别越低

 

由于每一层最多只影响两层，同事只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持

 

缺点：

并不是每个系统都可以很容易地划分为分层的模式

很难找到一个合适的、正确的层次抽象方法

 

进程通行：构件是独立的过程，连接件是消息传递。构建通常是命名过程，消息传递的方式可以使点对点、异步火同步方式，以及远程过程调用等

事件驱动（隐式调用）：构建不直接调用一个过程，而是触发或广播一个或多个事件。构建中的过程在一个或多个事件中注册，当某个时间被触发时，系统自动调用在这个事件中注册的所有过程。一个时间的触发就导致了另一个模块中的过程调用。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以过程之间的隐式调用来实现的。

优点：是为了软件复用提供了强大的支持，为构件的维护和演化提供了方便

缺点：构件放弃了对系统计算的控制

 

解释器：通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的原件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用，其缺点是执行效率低

基于规则的系统：包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工智能领域和DSS中

 

数据库系统：构件主要有两大类，一类是中央共享数据源，保存当前系统的数据状态；另一类是多个独立处理单元，处理党员对数据元素进行操作

黑板系统：包括知识源、黑板和控制三部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中（信号处理、问题规划和编译器优化等）

超文本系统：构件以王庄链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件。超文本是一种非线性的网状信息组织方法，它以节点为基本单位，链作为节点之间的联想方式关联。超文本系统通常应用在互联网领域

 

现代集成编译环境一般采用仓库风格

 

闭环控制架构：当软件被用来操作一个物理系统时，软件与硬件之间可以粗略地表示为一个反馈循环，这个反馈循环通过接受一定的输入，确定一系列的输出，最终使环境达到一个新的状态。适合于嵌入式系统，涉及连续的动作与状态

 

两层C/S架构：开发成本较，客户端程序设计复杂，信息内容和形式单一，用户界面风格不一，软件移植困难，软件维护和升级困难，新技术不能轻易应用

 

三层B/S架构：缺乏对动态页面的支持能力，没有集成有效的数据库处理功能，安全性难以控制，在数据查询等响应速度上，要远远低于C/S架构，数据提交一般以页面为单位，数据的动态交互性步枪，不利于OLTP应用

 

富互联网应用（RIA）：结合了C/S架构反应速度快，交互性强的优点，以及B/S架构传播范围广以及容易传播的特性，简化并改进了B/S架构的用户交互，数据能够被缓冲到客户端，从而可以实现一个比基于HTML的响应速度更快且数据往返于服务器的次数更少的用户界面

 

基于服务的架构（SOA）：服务构件粗粒度，传统构件细粒度居多，服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现，服务构件的实现与语言无关，传统构件绑定某种特定语言，服务构件可以用过构件容器提供QoS的服务，传统构件完全由程序代码直接控制

 

SOA关键技术：

发现服务：UDDI，DISCO

描述服务：WSDL，XML Schema

消息格式层：SOAP，REST

编码格式层：XML(DOM，SAX)

传输协议层：HTTP，TCP/IP，SMTP

 

SOA--关键技术--XML：

实现不同数据的集成，使用多种应用环境，客户端数据处理与计算，数据显示多样化，局部数更新，Web Service，数据集成，软件架构描述，软件架构演化，RIA，XML数据库

 

SOA--关键技术--REST：

HTTP+XML进行基于Web通信技术，简单性，缺少严格配置文件，只支持几个操作（POST，GET，PUT，DELETE），强调信息本身，称为资源

网络上的所有事物都被抽象为资源，每个资源对应一个唯一的资源标识，通过调用的连接器接口对资源进行操作，对资源的各种操作不会改变资源标识，所有操作都是无状态的

 

SOA--关键技术--UDDI&DISCO：

UDDI数据库模型：一个用于描述企业和夫妻的XML Schema

UDDI API：一组用于查找或发布UDDI数据的方法，基于SOAP

UDDI注册服务：一种基于设施，对应着服务注册中心的角色

 

DISCO可以定义一个文档格式和询问算法，发现给定服务器上公开的服务

DISCO能够发现内阁服务的功能（通过文档），以及如何与它进行交互（通过WSDL）

如果要使用DISCO发布一个已部署的服务，只需要创建一个.disco文件

 

SOA的实现方式--Web Service：注册中心（服务描述）<--发布-->服务提供着（服务，服务描述）<--绑定-->服务请求者<--查找-->注册中心

 

SOA的实现方式--ESB：

提供位置透明性的消息路由和寻址服务，提供服务注册和命名管理功能，支持多种的消息传递泛型，支持多种可以广泛使用的传输协议，支持多种数据格式及其项目转换，提供日志和监控功能

 

SAO的实现方式--服务注册：

服务注册：应用开发者（服务提供者）向注册表公布服务的功能

服务位置：服务使用者（服务应用开发者），帮助他们查询注册服务，寻找符合自身要求的服务

服务绑定：服务使用者利用检索到的服务接口来编写代码，所编写的代码将与注册的服务绑定过，调用注册的服务，以及与它们实现互动

 

 

微服务：就是很小的服务，所以他不属于面向服务架构的一种，它是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且嫩巩固独立的部署到生产环境，类生产环境等。另外，应当尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文选择合适的语言，工具对其进行构建。

特点：小，且专注于做一件事，轻量级的通信机制，松耦合，独立部署

优势：技术异构性，弹性，扩展，简化部署，与组织结构相匹配，可组合性，对可替代性的优化

面临挑战：分布式系统的复杂度，运维成本，部署自动化，DevOps与组织结构，服务间依赖测试，服务间依赖管理

 

微服务 SOA

能拆分就拆分 是整体的，服务能放一起都放一起

纵向业务划分 是水平分多层

由单一组织负责 按层级划分不同部门的组织负责

细粒度 粗粒度

两句话可以解释明白 几百字只相当于SOA的目录

独立的子公司 类似大公司里卖弄划分了一些业务单元

组件小 存在较复杂的组件

业务逻辑存在于每一个服务中 业务逻辑横跨多个业务领域

使用通过轻量级的通信方式 企业服务总线（ESB）充当了服务之间通信的角色

 

微服务架构实现 SOA实现

团队及，自底向上 秋娥及，自顶向下

一个系统被拆分成多个服务，细粒度 服务由多个子系统组成，粒度大

无集成式总线，松散的服务架构 企业服务总线，集中式的服务架构

集成方式简单（HTTP/REST/JSON） 集成方式复杂（ESB/WS/SOAP）

服务能独立部署 单块架构系统，相互依赖，部署复杂

 

架构描述语言（ADL）：它在底层予以模型的 支持下，为软件系统的概念体系结构建模提供了具体语法和概念框架。基于底层语义的工具为体系结构的表示，分析，演化，细化设计过程等提供支持。

 

ADL三个基本要素：

构件：计算或数据存储单元

连接件：用于构件之间交互建模的体系结构构造快及其支配这些交互的规则

架构配置：描述体系结构的构件与连接件的连接图

 

架构描述语言：

Aesop：支持体系结构风格的应用

MetaH：为设计者提供了关于实时电子控制软件系统的设计指导

C2：支持基于消息传递风格的用户界面系统的描述

Rapide：支持体系接哦古设计的模拟并提供了分析模拟结构的工具

SADL：提供了关于体系结构加细的形式话基础

Unicon：支持异构的构件和连接类型并提供了关于体系结构的高层编译器

Wright：支持体系结构构件之间交互的说明和分析

 

基于架构的软件设计（ABSD）:

是架构驱动，即强调由业务，质量和功能需求的组合驱动架构设计，设计活动可以从项目总体功能框架明确就开始，这意味着需求获取和分析还没有完成，就开始了软件设计

 

ABSD有三个基础：

1）功能分解，使用已有的基于模块的内聚和耦合技术。2）通过选择架构风格来实现质量和业务需求。3）软件模板的使用，软件模板利用了一些软件系统的结构

 

ABSD方法是递归的，且迭代的每一个步骤都是清晰地定义的。因此，不管设计是否完成，架构总是清晰的，这有助于降低架构设计的随意性

 

基于架构的软件开发方法----开发过程：架构需求，架构设计，架构文档化，架构复审，架构实现，架构演化

架构需求过程：需求获取，生成类图，对类进行分组，把类打包成构件，需求评审

架构设计过程：提出架构模式，映射构件，分析构件相互作用，生产架构，设计评审

架构实现过程：复审后的文档化架构，分析与设计，构件实现，构件组装，系统测试，架构演化

架构演化过程：需求变化归类，脚骨演化计划，构件变动，更新构件的相互作用，构件组装与测试，技术评审，演化后的架构

 

软件架构评估--质量属性

性能：系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件个数

代表参数：响应时间，吞吐量 设计策略：有限级队列，资源调度

 

可靠性：软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能性的基本能力

代表参数：MTTF，MTBF 设计策略：冗余，心跳线

 

可用性：系统能够正常运行的时间比例

代表参数：故障间隔时间 荣誉，心跳线

 

安全性：系统在想合法用户提供服务的同时能够阻止非授权用户使用服务的能力

设计策略：追踪审计，信息隐藏

 

可修改行：能够快速地以较高的性能价格比对系统进行变更后的能力

 

功能性：系统给所能完成期望的工作能力

 

可变性”：体系结构阔从或变更而成为新体系结构的能力

 

互操作性：作为系统组成部分的软件不是独立的，经常与其他系统或自身环境相互作用

 

 

软件脚骨评估--基于场景的方式：脚骨权衡分析法（ATAM），软件架构分析法（SAAM），成本效益分析法（CBAM）

 

中间件技术--概念：是一种独立的系统软件或服务程序，可以帮助分布式应用 软件在不同技术之间共享资源

 

主要的中间件：远程过程调用，对象请求代理，远程方法调用，面向消息的中间件，事物处理监控器

 

 

负载均衡技术：

基于特定软件的负载均衡（HTTP重定向）（应用层）

反向代理负载均衡（应用层）

基于DNS的负载均衡（传输层）

基于NAT的负载均衡（传输层）

混合型负载均衡

 

负载均衡的静态算法：轮转算法，加权轮转算法，源地址哈希散列算法目标地址哈希散列算法，随机算法

负载均衡动态算法：最小连接数算法，加权最小连接数算法，加权百分比算法

 

硬件负载均衡：F5 软件负载均衡：LVS，Nginx，HAproxy

 

REST的5个原则：

网络上的所有事物都被抽象为资源，每个资源对应一个唯一的资源标识，通过通用的额连接件接口对资源进行操作，对资源的各种操作不会改变资源标识，所有 的操作都是无状态的

 

响应式WEB设计的方法和策略：

采用流式布局和弹性化设计：使用相对单位，设定百分比而非具体的值的方式设置页面元素的大小

响应式图片：不仅要同比的缩放图片，嗨哟啊在小设备上降低土拍你自身的分辨率

 

对称加密：DES，RC-5，IDEA

缺陷：加密强度不高，但效率高，密钥分发困难

 

非对称加密：RSA，ECC

缺陷：加密速度慢

 

信息摘要：MD5，SHA

 

数字证书内容

证书版本信息，证书序列号，每个证书都有一个唯一的证书序列号，证书所使用的签名算法，证书发行机构名称，命名规则一般采用X.500格式，证书有效期，现在通用的证书一般采用UTC时间格式，1950-2049，证书所有人名称，命名规则一般采用X.500格式，证书所有人的公开密钥，证书发行者的证书的签名

 

被动攻击：手机信息为主，破坏保密性，攻击名称：窃听，业务流分析，非法登陆

主动攻击：主动攻击的类别主要有：中断（破坏可用性），篡改（破坏完整性），伪造（破坏真实性）。攻击名称：假冒身份，抵赖，旁路控制，重放攻击，拒绝服务（DOS）

 

 

可靠性：

软件可靠性 不等于 硬件可靠性

复杂性：软件复杂性比硬件高，大部分失效来自于软件失效

物理退化：硬件失效主要是物理退化所致，润建不存在物理退化

唯一性：软件是唯一的，每个COPY版本都一样，而两个硬件不可能完全一样

版本更新周期：硬件较慢，软件较快

 

可靠性设计：

结构冗余（硬件冗余，软件冗余），信息冗余（校验码），时间冗余（重读多次进行相同的计算）

 

可靠性设计包括：N版本程序设计，恢复快方法，防卫式程序设计，双机容错，集群技术

 

可靠性设计---防卫式程序设计：对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误回复代码，使得一旦错误发生，程序能撤销错误状态，回复到一个已知的是正确状态中去

 

实现策略：错误检测，破坏估计，错误恢复

 

可靠性设计---双机容错：双机热备份，双机互备份，双机双工模式

 

可靠性设计---集群技术：可伸缩性，高可用性，可管理型，高性价比，高透明性

 

范围管理：范围计划编制-->范围定义-->创建WBS-->范围确认-->范围控制

 

时间管理：活动定义-->活动排序-->活动资源估算-->活动历时估算-->制定进度计划-->进度控制

 

时间管理--甘特图：

优点：直观，容易制作，便于理解，能很清晰地标识出直到每一项任务的起始与结束时间，一般适用比较简单的小型项目，可用于WBS的任何层次，进度控制，资源优化，编制资源和费用计划

缺点：不能系统的表达一个项目所包含的各项工作自建的复杂关系，难以进行定量的计算和分析，以及计划的优化等

 

成本管理：

成本估算（自顶向下的估算，自底向上的估算，差别估算法）-->成本预算（直接成本与间接成本，管理储备，零基准预算）-->成本控制（净值分析）

 

成本管理--净值管：

计划工作量的预算成本（PV）=计划工作量*预算定额

已完成工作量的实际成本（AC）

已完成工作量的预算成本（EV）=已完成工作量*预算定额

完工预算（BAC）=完工时的PV总和

进度偏差（SV）=EV-PV

成本偏差（CV）=EV-AC

进度绩效指数（SPI）=EV/PV

成本绩效指数（CPI）=EV/AC

剩余工作的成本（ETC）=BAC-EV 或者 =(BAC-EV)/CPI

完工估算（EAC）=AC+ETC

 

软件质量管理--质量保证与质量控制

质量保证一般是每隔一定时间进行，主要通过系统的质量审计和过程分析来保证项目的质量，独特工具包括：质量审计和过程分析

 

质量控制的实时监控项目的具体结果，以判断它们是否符合相关质量标准，制定有效方案，以消除生产质量问题的原因

 

软件评审：不应以测试代替评审，评审人员应关注产品而不应评论开发人员，评审人员应关注于实质性问题，评审会议不应变为问题解决方案讨论会，评审应被安排进入项目计划，评审参与者应了解整个评审过程，评审人员事先应对评审材料充分了解，应重视评审的组织工作

 

软件过程改进

组织能力成熟度：

已管理级：需求管理，项目计划，配置管理，项目监督与控制，供应商合同管理，治疗和分析，过程和产品质量保证

已定义级：需求开发，技术解决方案，产品集成，验证，确认，组织级过程焦点，组织级过程定义，组织级培训，集成项目管理，风险管理，集成化的团队，决策分析和解决方案，组织级集成环境

定量管理级：组织级过程性能，定量项目管理

优化级：组织级改革与实施，因果分析和解决方案

 

软件配置管理--软件工具：

软件开发工具：需求分析工，设计工具，编码与排错工具

软件维护工具：版本控制工具，文档分析工具，开发信息库工具，逆向工程工具，再工程工具

软件管理和软件支持工具：项目管理工具，配置管理工具，软件评价工具，软件开发工具的评价和选择

 

软件配置管理--变更控制：变更申请-->变更评估-->变更决策-->变更实施-->变更验证-->沟通存档

 

风险管理：

风险讯在的客观性和普遍性，某一具体风险发生的偶然性和大量风险发生的必然性，风险的可变性，风险的多样性和多层次性

风险的基本属性：随机性和相对性

 

风险管理--风险的分类：

项目风险：

潜在的预算，进度，人员和组织，资源，用户和需求问题

技术风向：

潜在的设计，实现，接口，测试和维护方面的问题

商业风险：

市场风险：系统虽然很优秀但不是市场真正所想要的

策略风险：系统不再符合企业的信息系统战略

销售风险：开发了销售部门不清楚如何推销的系统

管理风险：由于重点转移或人员变动而失去上级支持

预算风险：开发过程没有得到预算或人员的保证

 

风向曝光度：风险出现的概率乘以风险可能造成的损失

 

项目管理工具”

能做什么：任务调度，成本估算，资源分配，预算跟踪，人时统计，配置控制，确定关键路径，松弛时间，超前时间和滞后时间，生成一定格式的报表和报告

不能做什么：不能知道软件设计人员按软件生存周期各个阶段的适用技术行进设计工作

```



## **测试**

```
未经测试的代码不应被投入生产环境。

在你的个人项目中，似乎不做任何测试是很方便的，但在商业和企业环境中工作时必须进行测试。因此对于任何开发人员而言，最好尽量将测试集成到开发工作流程中。

测试用例可以分为以下几类：

单元测试

在隔离环境中测试单个组件或函数。

集成测试

测试组件之间的交互。

端到端测试

在浏览器中测试完整功能的用户流。

还有更多测试方法，例如手动测试、快照测试等。如果你想升任高级开发人员职位，或打算在具备一些开发标准的大型公司工作，则应尝试提升自己的测试技能。
```



## js

### url到页面加载过程

```
1.DNS 解析
2.TCP 连接
3.HTTP 请求抛出
4.服务端处理请求，HTTP 响应返回
5.浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户
```

### 闭包

```
==================

闭包==>函数内部的函数

闭包的生成有三个必要条件（缺一不可）
1.在函数A内部直接或者间接返回一个函数B
2.B函数内部使用着A函数的私有变量(私有数据)
3.A函数外部有一个变量接收这个函数B
这样就形成了一个不会销毁的函数空间

闭包空间
1.我们管这个不会被销毁的A函数的执行空间叫做闭包空间
2.把函数A里面返回的函数B，叫做函数A的闭包函数
3.官方给的定义后一句话：闭包==>函数内部的函数

闭包的特点(优点和缺点并行)
1.延长了变量的生命周期
优点：因为执行空间不销毁，变量也就没有销毁
缺点：因为执行空间不销毁，会一直存在内存中
2.可以访问函数内部的私有变量
优点：利用闭包函数可以访问函数内部的私有变量
缺点：执行空间不会销毁，会一直存在内存中
3.保护私有变量(只要是函数就有这个特点)
优点：保护私有变量不被外界访问
缺点：如果想访问，必须要利用闭包函数

闭包函数的缺点"致命"
1.因为当一段内存空间中有一个不会被销毁的东西一直存在
2.那么就会出现内存占用，如果过多，就会导致内存溢出
3.那么结果就是内存泄露

啥时候用闭包好
1.就是当你需要延长变量的生命周期的时候
2.或者你需要访问某一个函数内部的私有变量的时候

====================================

什么是闭包
闭包是一个密闭的容器，类似于set，map容器，用来储存数据的。闭包也是一个对象，存储数据的格式：key：value

闭包形成的条件
函数的嵌套
内部函数引用外部函数的变量
闭包的优缺点
优点：可以延长外部函数局部变量的存储时间
缺点：容易造成内存的泄漏
```

### 作用域

```
作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。
Global {
  outer {
    inner
  }
}

在这里，inner 函数可以访问在其自己的作用域、outer 函数的作用域和全局作用域中定义的变量。而 outer 函数可以访问在它自己的作用域和全局作用域内定义的变量。

计数器
function getCounter() {
  let counter = 0;
  return function() {
    return counter++;
  }
}
let count = getCounter();
console.log(count());  // 0
console.log(count());  // 1
console.log(count());  // 2
复制代码同样，我们将 getCounter 函数返回的匿名内部函数赋值给 count 变量。count 函数现在就成为了一个闭包，即使 getCounter() 执行完毕，它依然可以访问 getCounter 函数内部的 counter 变量。
但是请注意，每次 count 执行的时候 counter 的值并不会重置为 0 。
这是因为，每次调用 count()，将会为该函数创建一个新的作用域，但是这里只给 getCounter 创建了一个作用域，又因为 counter 变量是定义在 getCounter 函数作用域内部的，所以它将在每次 count 调用的时候自增而不是被重置。

===================================

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：

function outFun2() {
    var inVariable = "内层变量2";
}
outFun2();//要先执行这个函数，否则根本不知道里面是啥
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
从上面的例子可以体会到作用域的概念，变量 inVariable 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。

所有末定义直接赋值的变量自动声明为拥有全局作用域
function outFun2() {
    variable = "未定义直接赋值的变量";
    var inVariable2 = "内层变量2";
}
outFun2();//要先执行这个函数，否则根本不知道里面是啥
console.log(variable); //未定义直接赋值的变量
console.log(inVariable2); //inVariable2 is not defined

所有 window 对象的属性拥有全局作用域
一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。

全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。

// 张三写的代码中
var data = {a: 100}
​
// 李四写的代码中
var data = {x: true}
这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。



```

#### **块级作用域**

```
声明变量不会提升到代码块顶部
let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。

禁止重复声明
var count = 30;
let count = 40; 

循环中的绑定块作用域的妙用
开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如，以下代码在 JS 经常见到：

<button>测试1</button>
<button>测试2</button>
<button>测试3</button>
<script type="text/javascript">
   var btns = document.getElementsByTagName('button')
    for (var i = 0; i < btns.length; i++) {
      btns[i].onclick = function () {
        console.log('第' + (i + 1) + '个')
      }
    }
</script>
我们要实现这样的一个需求: 点击某个按钮, 提示"点击的是第 n 个按钮",此处我们先不考虑事件代理,万万没想到，点击任意一个按钮，后台都是弹出“第四个”,这是因为 i 是全局变量,执行到点击事件时，此时 i 的值为 3。那该如何修改，最简单的是用 let 声明 i

 for (let i = 0; i < btns.length; i++) {
    btns[i].onclick = function () {
      console.log('第' + (i + 1) + '个')
    }
  }
```

#### **作用域链**

```
 作用域和执行上下文之间最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。
 
 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。
 
 
 
 什么是作用域链
如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

var a = 100
function F1() {
    var b = 200
    function F2() {
        var c = 300
        console.log(a) // 自由变量，顺作用域链向父作用域找
        console.log(b) // 自由变量，顺作用域链向父作用域找
        console.log(c) // 本作用域的变量
    }
    F2()
}
F1()
```



### ==与===

```
'' == '0'           // false 0 == ''             // true 0 == '0'            // true  false == 'false'    // false false == '0'        // true  false == undefined  // false false == null       // false null == undefined   // true  ' \t\r\n ' == 0     // true

==有时候类型并不一样也相等
Couldn't resolve extends clause of ./.config/babel.config
```



### JS事件冒泡与捕获

概念：当给子元素和父元素定义了相同的事件，比如都定义了onclick事件，点击子元素时，父元素的onclick事件也会被触发。js里称这种事件连续发生的机制为事件冒泡或者事件捕获。

W3C标准将两者进行中和，在任何的W3C的事件模型中， 事件先进入捕获阶段，再进入冒泡阶段

```
什么是冒泡与捕获
        以click点击事件为例。假如我们有一个多层结构标签。如下图，是4个div嵌套。每个div都有点击的监听事件，分别输出1234。当我们点击最里面的div时，点击事件开始传递，传递的全过程是1-2-3-4-4-3-2-1。
前半部分，事件从最外面的父div依次传递到最里面的后代div，1-2-3-4这部分我们叫捕获过程。
之后事件又从最里层的后代div逐层传出，4-3-2-1这部分我们叫冒泡过程。

如果我把捕获监听器和冒泡监听器都加上，如下图这样。

```

![img](https://upload-images.jianshu.io/upload_images/15214039-8ae777372e2e8a84.png?imageMogr2/auto-orient/strip|imageView2/2/w/916/format/webp)



这时我们有8个监听器了，在捕获过程和冒泡过程都有监听。输出如下图。

![img](https:////upload-images.jianshu.io/upload_images/15214039-017e8485c65f5255.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

先捕获后冒泡

如果我去除几个监听器如下图。为了容易理解我调整了格式

![img](https:////upload-images.jianshu.io/upload_images/15214039-b049bd78f33eea31.png?imageMogr2/auto-orient/strip|imageView2/2/w/945/format/webp)

举一反三

仍然是按照箭头顺序，明显应该输出1423。

![img](https:////upload-images.jianshu.io/upload_images/15214039-c9dbd228fe2182a9.png?imageMogr2/auto-orient/strip|imageView2/2/w/610/format/webp)

举一反三

#### 阻止传递

在不使用任何框架的情况下，我们在js中通过stopPropagation方法阻止事件继续传递。 
    使用框架时可使用对应的框架提供的方法。接下来我将了Vue框架的stop修饰符来阻止事件传递。

​    我们可以在传递过程中阻止事件继续传递，防止触发不需要的事件。

![img](https:////upload-images.jianshu.io/upload_images/15214039-d2d57ee4dd5c5f85.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)

阻止传递

如图我在第三层捕获后阻止事件继续传递，那么后面的log方法不会继续执行。最终只输出1-2-3。

![img](https:////upload-images.jianshu.io/upload_images/15214039-a92a51eb67d49dfe.png?imageMogr2/auto-orient/strip|imageView2/2/w/609/format/webp)

输出结果

#### 应用场景举例

​    我们在使用中多数情况下只使用冒泡监听。例如一条购物车信息，在这条信息中，右下角有一个删除按钮。点击这条消息可查看详情，点击删除按钮可将此商品移除。我们会分别给信息的div和删除button添加一个冒泡的click事件监听。如果不做阻止传递，点击删除button后，会显示商品详情。显然这不是我们想看到的。这时我们给button一个阻止事件传递的功能，点击删除按钮后，事件就会结束，就不再显示商品详情。

![img](https://www.pianshen.com/images/209/772280dd69d81e0ad9cb336807bf5869.png)

### 阻止浏览器事件冒泡

```
不同的浏览器对事件的解析机制不同，所以就会触发不同的事件，影响我们操作，如何取解决浏览器事件冒泡

，所谓的事件冒泡就是子元素添加一个事件父元素也会触发该事件，就称为事件冒泡。

在 火狐浏览器使用：

var e = e || window.event;

e.stopPropagation();

对于IE 使用 ：

e.cancelBubble = true;

同时兼容火狐和IE：

if (e && e.stopPropagation) {

e.stopPropagation();

} else if (window.event) {

e.cancelBubble = true;

}

这样就能解决事件冒泡问题了。

```



### **浏览器线程**

```
 浏览器线程
进程、线程
进程代表的是一个程序（浏览器开一个页卡就是一个进程）
线程是用来处理进程中的具体事物，如果一个进程中有很多事情要做，就可以开辟很多线程
一个线程同时只能做一件事
浏览器是多线程的
GUI渲染线程
HTTP网络线程
JS渲染线程
定时器监听线程
事件触发线程
JS是单线程的：浏览器只分配一个线程来渲染JS代码
JS中的代码大部分都是同步编程，即上面的任务没有完成，下面的任务是无法处理的
但是JS可以利用浏览器的多线程机制，规划出异步编程效果
定时器、AJAX/Fetch/跨域（HTTP网络请求）、事件绑定、promise中的异步、Generator函数、async/await等

interval设置为零也不是立即执行，而是浏览器都有最快反应时间（谷歌:5~6ms IE:13~17ms），设置为零，最快也需要等到5～6ms左右


```

### 同步异步执行图解

![image-20220219192402669](E:\zokoko\相关\tips\mdTips\mdImage\image-20220219192402669.png)

### 宏任务微任务

https://zhuanlan.zhihu.com/p/354019354

从上到下执行完同步任务——await的同步——promise的同步——resolve后再执行微任务，最后setimeout？



### Event Loop

```
Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理

同步任务
在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

异步任务
不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。


在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。

MacroTask（宏任务）
script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。


MicroTask（微任务）
Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里）

async/await。
async/await 在底层转换成了 promise 和 then 回调函数。

async function f() {
  await p
  console.log('ok')
}
简化理解为：

function f() {
  return RESOLVE(p).then(() => {
    console.log('ok')
  })
}

```



### http状态码

```
301 redirect: 301 代表永久性转移(Permanently Moved)

        302 redirect: 302 代表暂时性转移(Temporarily Moved )
        
        200("OK")
一切正常。实体主体中的文档（若存在的话）是某资源的表示。

400("Bad Request")
客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。

500("Internal Server Error")
服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。

301("Moved Permanently")
当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。

404("Not Found") 和410("Gone")
当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。

409("Conflict")
当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。
```



### ajax

```
xmlhttp.open("GET","ajax_info.txt",true);
xmlhttp.send();

xmlhttp.open("POST","/try/ajax/demo_post2.php",true);
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xmlhttp.send("fname=Henry&lname=Ford");
```

### ajax跨域

```
一般ajax跨域解决就是通过JSONP解决或者CORS解决

JSONP
客户端网页网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制

function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('response data: ' + JSON.stringify(data));
};                      
    
    
    
    服务端对应的接口在返回参数外面添加函数包裹层
foo({
  "test": "testData"
});             


Access-Control-Allow-Headers: X-Requested-With,Content-Type,Accept
Access-Control-Allow-Methods: Get,Post,Put,OPTIONS
Access-Control-Allow-Origin: *

第一步:配置Php 后台允许跨域
<?php
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept');
//主要为跨域CORS配置的两大基本信息,Origin和headers
```



## 

## ts和js的区别

```
ts和js的区别
1，ts是静态类语言，可以做到声明即文档，js是动态类语言相对更灵活。
2，如用ts写一个button组件可以清晰的知道，ButtonProps如是否必传，可选，style是什么类型，disabled是什么类型，较js，ts更易于维护和拓展，可以做到代码即注释，避免一个月不见3，代码自己都忘记自己写了什么的尴尬，
4，ts对比js基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型
5，js没有重载概念，ts有可以重载
6，vscode/ide对ts有很友好的提示
7，ts更利于重构


TypeScript的类定义与ES6
可见TypeScript的类定义与ES6十分相似，只不过TypeScript中增加了属性类型定义

关于继承，ES6与TypeScript有以下共同点

都是采用extends语法进行继承
在constructor中都需要首先使用super(xxx)调用父类构造函数，然后才能给this进行赋值
supper作为方法时指向父类构造函数，而作为对象且在普通方法中时指向父类的原型，在静态方法中时指向父类。(但TypeScript中直接使用静态方法中的supper获取属性值时会报错Only public and protected methods of the base class are accessible via the 'super' keyword.（表示supper在子类静态方法中只能调用父类的静态方法），可是最终编译的结果却符合ES6规范，这里可能是TypeScript编译器中的BUG，有兴趣的可以自己试试)
最终都是通过ES5的原型链进行继承
不同点

TypeScript提供抽象类，抽象方法，和接口继承，具体使用请参考TypeScript官方文档。
TypeScript可以对类中属性或方法使用访问限定符。

```



## react

### 概述

```
1. 精通React框架；
2. 熟悉HTML5，JavaScript，ES6， TypeScript，CSS3， sass， Webpack；
3. 对前端代码规范、组件、测试、发布等有深入认识及实践；
4. 优秀的沟通协作能力，团队管理能力，英文文档阅读能力。
岗位职责：
1. 负责开发公司各平台系统的前端产品，编写相关的技术文档、单元测试，保证产品质量。
2. 与产品经理和设计师合作，高质量完成前端产品技术规划、开发和迭代更新；
3. 确保UI的高度还原，提高代码性能，并保持Web的良好兼容性；
4. 配合后端开发工程师进行接口联调，完成Web前端开发。
=============================
React 使用 JSX 来替代常规的 JavaScript。

JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。

我们不需要一定使用 JSX，但它有以下优点：

JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。
它是类型安全的，在编译过程中就能发现错误。
使用 JSX 编写模板更加简单快速。
```

### 基础特性

```
独立文件
你的 React JSX 代码可以放在一个独立文件上，例如我们创建一个 helloworld_react.js 文件，代码如下：

ReactDOM.render(
  <h1>Hello, world!</h1>,
  document.getElementById('example')
);
然后在 HTML 文件中引入该 JS 文件：

React 实例
<body>
  <div id="example"></div>
<script type="text/babel" src="helloworld_react.js"></script>
</body>

============================

JavaScript 表达式
我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：

React 实例
ReactDOM.render(
    <div>
      <h1>{1+1}</h1>
    </div>
    ,
    document.getElementById('example')
);


在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.

React 实例
ReactDOM.render(
    <div>
      <h1>{i == 1 ? 'True!' : 'False'}</h1>
    </div>
    ,
    document.getElementById('example')
);
==========================
样式
React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式：

React 实例
var myStyle = {
    fontSize: 100,
    color: '#FF0000'
};
ReactDOM.render(
    <h1 style = {myStyle}>菜鸟教程</h1>,
    document.getElementById('example')
);
================
注释
注释需要写在花括号中，实例如下：

React 实例
ReactDOM.render(
    <div>
    <h1>菜鸟教程</h1>
    {/*注释...*/}
     </div>,
    document.getElementById('example')
);
================================
数组
JSX 允许在模板中插入数组，数组会自动展开所有成员：

React 实例
var arr = [
  <h1>菜鸟教程</h1>,
  <h2>学的不仅是技术，更是梦想！</h2>,
];
ReactDOM.render(
  <div>{arr}</div>,
  document.getElementById('example')
);

改版写法:

 1. 使用 ES6 类写法，用 this.props.属性名 来取值。
 2. 可以多层 props 来传值，在 ReactDOM.render 定义属性值，传给调用方法 App，再在调用的ES6类调用中用 props.属性直接赋值过去。
 ==========================================
 多个属性的传入注意不用逗号或分号隔开而是空格符隔开:

ReactDOM.render(
     <App name={"菜鸟教程"} url={"http://www.runoob.com"} nickname={"Runoob"}/>,
    document.getElementById('example')
);
```



### 更新元素渲染

```
更新元素渲染
React 元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。

目前更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法：

来看一下这个计时器的例子:

实例
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>现在是 {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(
    element,
    document.getElementById('example')
  );
}
 
setInterval(tick, 1000);
```

### 组件

```
接下来我们封装一个输出 "Hello World！" 的组件，组件名为 HelloMessage：

React 实例
function HelloMessage(props) {
    return <h1>Hello World!</h1>;
}
 
const element = <HelloMessage />;
 
ReactDOM.render(
    element,
    document.getElementById('example')
);
```

### 复合组件

```
function Name(props) {
    return <h1>网站名称：{props.name}</h1>;
}
function Url(props) {
    return <h1>网站地址：{props.url}</h1>;
}
function Nickname(props) {
    return <h1>网站小名：{props.nickname}</h1>;
}
function App() {
    return (
    <div>
        <Name name="菜鸟教程" />
        <Url url="http://www.runoob.com" />
        <Nickname nickname="Runoob" />
    </div>
    );
}
 
ReactDOM.render(
     <App />,
    document.getElementById('example')
);
```

### React Props

```
state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。


使用 Props
以下实例演示了如何在组件中使用 props：

React 实例
function HelloMessage(props) {
    return <h1>Hello {props.name}!</h1>;
}
 
const element = <HelloMessage name="Runoob"/>;
 
ReactDOM.render(
    element,
    document.getElementById('example')
);


State 和 Props
以下实例演示了如何在应用中组合使用 state 和 props 。我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。在 render 函数中, 我们设置 name 和 site 来获取父组件传递过来的数据。

React 实例
class WebSite extends React.Component {
  constructor() {
      super();
 
      this.state = {
        name: "菜鸟教程",
        site: "https://www.runoob.com"
      }
    }
  render() {
    return (
      <div>
        <Name name={this.state.name} />
        <Link site={this.state.site} />
      </div>
    );
  }
}
 
 
 
class Name extends React.Component {
  render() {
    return (
      <h1>{this.props.name}</h1>
    );
  }
}
 
class Link extends React.Component {
  render() {
    return (
      <a href={this.props.site}>
        {this.props.site}
      </a>
    );
  }
}
 
ReactDOM.render(
  <WebSite />,
  document.getElementById('example')
);
```

### Props 验证

```
MyComponent.propTypes = {
    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的
   optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,
 
    // 可以被渲染的对象 numbers, strings, elements 或 array
    optionalNode: React.PropTypes.node,
 
    //  React 元素
    optionalElement: React.PropTypes.element,
 
    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),
 
    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),
 
    // 可以是多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),
 
    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),
 
    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),
 
    // 特定 shape 参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),
 
    // 任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,
 
    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,
 
    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  }
}
```

### React 组件生命周期

- ```
  在本章节中我们将讨论 React 组件的生命周期。
  
  组件的生命周期可分成三个状态：
  
  - Mounting(挂载)：已插入真实 DOM
  - Updating(更新)：正在被重新渲染
  - Unmounting(卸载)：已移出真实 DOM
  ```

  ### 

### React AJAX

```
React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据时可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。

当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。

以下实例演示了获取 Github 用户最新 gist 共享描述:

class UserGist extends React.Component {
  constructor(props) {
      super(props);
      this.state = {username: '', lastGistUrl: ''};
  }
 
 
  componentDidMount() {
    this.serverRequest = $.get(this.props.source, function (result) {
      var lastGist = result[0];
      this.setState({
        username: lastGist.owner.login,
        lastGistUrl: lastGist.html_url
      });
    }.bind(this));
  }
 
  componentWillUnmount() {
    this.serverRequest.abort();
  }
 
  render() {
    return (
      <div>
        {this.state.username} 用户最新的 Gist 共享地址：
        <a href={this.state.lastGistUrl}>{this.state.lastGistUrl}</a>
      </div>
    );
  }
}
 
ReactDOM.render(
  <UserGist source="https://api.github.com/users/octocat/gists" />,
  document.getElementById('example')
);
```

### React Refs

```
你可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用，实例如下：

React 实例
class MyComponent extends React.Component {
  handleClick() {
    // 使用原生的 DOM API 获取焦点
    this.refs.myInput.focus();
  }
  render() {
    //  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs
    return (
      <div>
        <input type="text" ref="myInput" />
        <input
          type="button"
          value="点我输入框获取焦点"
          onClick={this.handleClick.bind(this)}
        />
      </div>
    );
  }
}
 
ReactDOM.render(
  <MyComponent />,
  document.getElementById('example')
);
```

### React Redux

```
在这里我们引入了connect()，它能帮助我们把组件和store连接起来，并且可以获取state。

我们声明了一个新的函数叫 mapStateToProps() ，当然函数名也可以是别的，它从store中获取state值作为它的参数，返回了一个对象。

为了获取到store中的state，我们需要把 mapStateToProps() 作为connect函数的参数。
好了， 这些就是基本的redux的知识。我们不难发现，这样其实挺麻烦的。你需要写好多好多东西，而且我们并没有把reducer，action什么的给分离出去，不然的话我还要往很多组件里面传很多东西。这对我们实际开发是很不友好的。
所以， 这时候就十分迫切需要react-redux了。它的作用是帮助我们操作redux。有了它我们可以很方便的写redux。接下来上代码：

Provider：它是react-redux 提供的一个 React 组件，作用是把state传给它的所有子组件，也就是说 当你用Provider传入数据后 ，下面的所有子组件都可以共享数据，十分的方便。
Provider的使用方法是：把Provider组件包裹在最外层的组件，如代码所示，把整个APP组件给包裹住，然后在Provider里面把store传过去。注意：一定是在Provider中传store，不能在APP组件中传store。

connect的使用方法是：把指定的state和指定的action与React组件连接起来，后面括号里面写UI组件名。

除此之外demo中还多出了mapStateToProps mapDispatchToProps 他们又有什么作用呢？通俗一点讲的话就是：
比如你在一个很深的UI组件里 当你想要获得store的数据就很麻烦。mapStateToProps就是告诉store你需要哪个state，需要什么数据就直接在mapStateToProps中写出来，然后store就会返回给你。同理，如果你想要dispatch派发一些行为怎么办呢，mapDispatchToProps就是告诉store你要派发什么行为，需要派发什么行为就在mapDispatchToProps中写出来，然后store就会把你想要派发的行为告诉reducer，接下来大家都应该知道了 reducer就会根据旧的state和action返回新的state。

ok， 这个简单的demo我们就实现了。但是现在还有一个问题：我们把所有的action reducer store Provider connect等等都写在了一个页面，这在我们实际开发中肯定是不合理的，所以，我们最后就给这个小demo再优化下：
首先，我们要把action，reducer什么的抽离出去，作为一个单独的文件，然后再导出：



import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import { createStore } from 'redux';
import { Provider, connect } from 'react-redux';

class App extends Component {
    render() {
        const { PayIncrease, PayDecrease } = this.props;
        return (
            <div className="App">
                <div className="App">
                    <h2>当月工资为{this.props.tiger}</h2>
                    <button onClick={PayIncrease}>升职加薪</button>
                    <button onClick={PayDecrease}>迟到罚款</button>
                </div>
            </div>
        );
    }
}

const tiger = 10000

//这是action
const increase = {
    type: '涨工资'
}
const decrease = {
    type: '扣工资'
}
//这是reducer
const reducer = (state = tiger, action) => {
    switch (action.type) {
        case '涨工资':
            return state += 100;
        case '扣工资':
            return state -= 100;
        default:
            return state;
    }
}

//创建store
const store = createStore(reducer);

//需要渲染什么数据
function mapStateToProps(state) {
    return {
        tiger: state
    }
}
//需要触发什么行为
function mapDispatchToProps(dispatch) {
    return {
        PayIncrease: () => dispatch({ type: '涨工资' }),
        PayDecrease: () => dispatch({ type: '扣工资' })
    }
}

//连接组件
App = connect(mapStateToProps, mapDispatchToProps)(App)

ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
)



```

### Reducer

```
Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。
这里大概解释下每个的意思：
action：行为 它是一个对象 里面必有type来指定其类型 这个类型可以理解为你要做什么，reducer要根据action的type来返回不同的state 每个项目有且可以有多个action
reducer： 可以理解为一个专门处理state的工厂 给他一个旧数据它会根据不同action.type返回新的数据 也就是：旧state + action = 新state 每个项目有且可以有多个reducer
store： store本质上是一个状态树，保存了所有对象的状态。任何UI组件都能直接的从store访问特定对象的状态。每个项目有且只能有一个store
脑子里有了这些基本的概念后我们就可以把reducer放到createStore里并创建好store了
可以看到， 打印的数据变成了 11000 也就是说reducer根据dispatch派发的action的type，return了新的state。当然我们也可以派发store.dispatch(decrease) 那打印的结果就是 10000，原因想必大家都知道。
其实我们仅仅是多写了store.dispatch(increase) 和 store.subscribe(() =>{}） 他们的每个作用大概解释下：
dispatch的作用就是告诉reducer 我给你action, 你要根据我的action.type返回新的state。 然后reducer就会根据action的type，返回新的state。
我们给它dispatch了action，reducer也做出相应 最后也返回新的state 但是其实这时候console.log()不会打印新的数据 因为state虽然变化了 但是还是打印store.getState()还是原始的数据
这时候我们就需要store.subscribe(() =>{}）了 它的作用就是每当reducer返回新的数据 它就会自动更新页面 把UI组件的state更新下 不然的话 虽然state变化了 页面仍不会更新（虽然现在还没有其他组件）


import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import registerServiceWorker from './registerServiceWorker';
import { createStore } from 'redux' 
 
const tiger = 10000

//这是action
const increase = {
    type:'涨工资'
}
const decrease = {
    type:'扣工资'
}
//这是reducer
const reducer = (state = tiger, action) => {
    switch (action.type){
      case '涨工资': 
        return state += 100;
      case '扣工资': 
        return state -= 100;
      default: 
        return state;
    }
}

//创建store
const store = createStore(reducer);

//订阅事件
store.subscribe(() =>
  console.log(store.getState())
);

//派发事件
store.dispatch(increase)

ReactDOM.render(<App />, document.getElementById('root'));
registerServiceWorker();




```

### react hooks

概述

```
至此，文章关于React Hooks的讲解结束，它为我们带来了React翻天覆地的变化，也让我们感受到了React的未来，不过，假如你不会Hooks也是没有关系的。根据官方文档的话来说

完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。
100% 向后兼容的。 Hook 不包含任何破坏性改动。
现在可用。 Hook 已发布于 v16.8.0。
没有计划从 React 中移除 class。
Hook 不会影响你对 React 概念的理解。 恰恰相反，Hook 为已知的 React 概念提供了更直接的 API：props， state，context，refs 以及生命周期。

```



#### 一、userState():状态钩子

```

我们知道，纯函数组件没有状态，useState()用于为函数组件引入状态。
下面我们使用Hooks重写上面的计数器。

import React, {useState} from 'react'
const AddCount = () => {
  const [ count, setCount ] = useState(0)
  const addcount = () => {
    let newCount = count
    setCount(newCount+=1)
  } 
  return (
    <>
      <p>{count}</p>
      <button onClick={addcount}>count++</button>
    </>
  )
}
export default AddCount 

```

#### 二、useContext():共享状态钩子

```
现在假设有A组件和B组件需要共享一个状态。

import React,{ useContext } from 'react'
const Ceshi = () => {
  const AppContext = React.createContext({})
  const A =() => {
    const { name } = useContext(AppContext)
    return (
        <p>我是A组件的名字{name}<span>我是A的子组件{name}</span></p>
    )
}
const B =() => {
  const { name } = useContext(AppContext)
  return (
      <p>我是B组件的名字{name}</p>
  )
}
  return (
    <AppContext.Provider value={{name: 'hook测试'}}>
    <A/>
    <B/>
    </AppContext.Provider>
  )
}
export default Ceshi 

```

#### 三、useReducer():Action钩子

```
我们知道，在使用React的过程中，如遇到状态管理，我们一般会用到Redux,而React本身是不提供状态管理的。而useReducer()为我们提供了状态管理。首先，关于redux我们都知道，其原理是我们通过用户在页面中发起action,从而通过reducer方法来改变state,从而实现页面和状态的通信。而Reducer的形式是(state, action) => newstate。类似，我们的useReducer()是这样的

const [state, dispatch] = useReducer(reducer, initialState)


和redux一样，我们是需要通过页面组件发起action来调用reducer方法，从而改变状态，达到改变页面UI的这样一个过程。所以我们会先写一个Reducer函数，然后通过useReducer()返回给我们的state和dispatch来驱动这个数据流。思路就是这样，下面我们上代码

import React,{useReducer} from 'react'

const AddCount = () => {
const reducer = (state, action) =>  {
 if(action.type === ''add){
  return {
  ...state,
  count: state.count +1,
  }
 }else {
   return state
  }
 }
const addcount = () => { 
  dispatch({
    type: 'add'
  })
 }
const [state, dispatch] = useReducer(reducer, {count: 0})
return (
<>
<p>{state.count}</p>
<button onClick={addcount}>count++</button>
</>
)
}
export default AddCount

```

#### 四、useEffect():副作用钩子

```
useEffect()接受两个参数，第一个参数是你要进行的异步操作，第二个参数是一个数组，用来给出Effect的依赖项。只要这个数组发生变化，useEffect()就会执行。当第二项省略不填时，useEffect()会在每次组件渲染时执行。这一点类似于类组件的componentDidMount。下面我们通过代码模拟一个异步加载数据。


import React, { useState, useEffect } from 'react'
const AsyncPage = () => {
const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(()=> {
      setLoading(false)
    },5000)
  })
return (
loading ? <p>Loading...</p>: <p>异步请求完成</p>
)
}

export default AsyncPage 

上面的代码实现了一个异步加载，下面我们再做一个useEffect()依赖第二项数组变化的例子。

import React, { useState, useEffect } from 'react'

const AsyncPage = ({name}) => {
const [loading, setLoading] = useState(true)
const [person, setPerson] = useState({})

  useEffect(() => {
    setLoading(true)
    setTimeout(()=> {
      setLoading(false)
      setPerson({name})
    },2000)
  },[name])
  return (
    <>
      {loading?<p>Loading...</p>:<p>{person.name}</p>}
    </>
  )
}

const PersonPage = () =>{
  const [state, setState] = useState('')
  const changeName = (name) => {
    setState(name)
  }
  return (
    <>
      <AsyncPage name={state}/>
      <button onClick={() => {changeName('名字1')}}>名字1</button>
      <button onClick={() => {changeName('名字2')}}>名字2</button>
    </>
  )
}

export default PersonPage 

上面代码中，通过改变传给AsyncPage的props,从而调用useEffect()

```

#### 五、创建自己的Hooks

```
上面代码中，我们将之前的例子封装成了自己的Hooks,便于共享。其中，我们定义usePerson()为我们的自定义Hooks,它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后我们在使用usePerson()时，会根据我们传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。


import React, { useState, useEffect } from 'react'

const usePerson = (name) => {
const [loading, setLoading] = useState(true)
const [person, setPerson] = useState({})

  useEffect(() => {
    setLoading(true)
    setTimeout(()=> {
      setLoading(false)
      setPerson({name})
    },2000)
  },[name])
  return [loading,person]
}

const AsyncPage = ({name}) => {
  const [loading, person] = usePerson(name)
    return (
      <>
        {loading?<p>Loading...</p>:<p>{person.name}</p>}
      </>
    )
  }

const PersonPage = () =>{
  const [state, setState]=useState('')
  const changeName = (name) => {
    setState(name)
  }
  return (
    <>
      <AsyncPage name={state}/>
      <button onClick={() => {changeName('名字1')}}>名字1</button>
      <button onClick={() => {changeName('名字2')}}>名字2</button>
    </>
  )
}

export default PersonPage 

```

## 浏览器插件

### chrome

正常的manifest

#### 概述

```
一般我们会在浏览器的前台页面，也就是直接打开控制台就可以看到的扩展程序，通过contentScript指定加载的程序。在这里监听当前浏览器当前打开的页面，然后做一些与用户交互的东西。

5.2 在前台的交互，以消息的形式传递到background指定的脚本。

contentScript执行的程序一般可以跨域，浏览器的安全限制，而background指定的脚本可以跨域运行，获取所有浏览器cookie信息等等。

获取当前窗口ID
chrome.windows.getCurrent(function(currentWindow)
{
	console.log('当前窗口ID：' + currentWindow.id);
});
8.4. 获取当前标签页ID
一般有2种方法：

// 获取当前选项卡ID
function getCurrentTabId(callback)
{
	chrome.tabs.query({active: true, currentWindow: true}, function(tabs)
	{
		if(callback) callback(tabs.length ? tabs[0].id: null);
	});
}
获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）

// 获取当前选项卡ID
function getCurrentTabId2()
{
	chrome.windows.getCurrent(function(currentWindow)
	{
		chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs)
		{
			if(callback) callback(tabs.length ? tabs[0].id: null);
		});
	});
}
```

#### 消息传参

```
chrome.runtime.sendMessage(string extensionId, any message, object options, function responseCallback)

chrome.runtime.onMessage.addListener(function callback)
```



#### 新增快捷键

```
 {
     "name": "Hello Extensions",
    "description" : "Hello world Extension",
    "version": "1.0",
    "manifest_version": 2,
    "browser_action": {
      "default_popup": "hello.html",
      "default_icon": "hello_extensions.png"
    },

#新增内容如下
   "commands": {
      "_execute_browser_action": {
        "suggested_key": {
          "default": "Ctrl+Shift+F",
          "mac": "MacCtrl+Shift+F"
        },
        "description": "Opens hello.html"
      }
    }
  }
```

#### permissions 

```
"permissions": [
    "tabs",
    "storage",
    "http://*/*",
    "https://*/*"
  ],
```

#### contentScripts

```
运行在浏览器网页的上下文页面，使用标准的DOM模型，contentScripts标签在控制台可以看到。

 "content_scripts": [
    {
      "matches": [
        "http://*/*",
        "https://*/*"
      ],
      "js": [
        "scripts/contentscript.js"
      ],
      "run_at": "document_end",
      "all_frames": false
    }
  ],
  
  
  content-script一样使用Message交互的方式与background页面进行通信
  
  
```

#### background

```
background后台页面，在浏览器前台看不到的页面，可以以后台进程的方式进行运行，也可以以事件的方式运行。需要打开扩展程序的开发者模式才能看到

"background": {
    "scripts": [
      "scripts/background.js"
    ]
  },
  
  
 background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。

经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。
```

####  右键菜单

```
通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下：、


// manifest.json
{"permissions": ["contextMenus"]}

// background.js
chrome.contextMenus.create({
	title: "测试右键菜单",
	onclick: function(){alert('您点击了右键菜单！');}
});

```

#### 桌面通知

```
Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。

在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。

最简单的通知：

chrome.notifications.create(null, {
	type: 'basic',
	iconUrl: 'img/icon.png',
	title: '这是标题',
	message: '您刚才点击了自定义右键菜单！'
});
```

#### 5种类型的JS对比

```

```

#### 5种类型的JS对比 ，权限对比

| JS种类          | 可访问的API                                    | DOM访问情况  | JS访问情况 | 直接跨域 |
| --------------- | ---------------------------------------------- | ------------ | ---------- | -------- |
| injected script | 和普通JS无任何差别，不能访问任何扩展API        | 可以访问     | 可以访问   | 不可以   |
| content script  | 只能访问 extension、runtime等部分API           | 可以访问     | 不可以     | 不可以   |
| popup js        | 可访问绝大部分API，除了devtools系列            | 不可直接访问 | 不可以     | 可以     |
| background js   | 可访问绝大部分API，除了devtools系列            | 不可直接访问 | 不可以     | 可以     |
| devtools js     | 只能访问 devtools、extension、runtime等部分API | 可以         | 可以       | 不可以   |

#### 消息通信

前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。

#### 7.1. 互相通信概览

注：`-`表示不存在或者无意义，或者待验证。

|                 | injected-script                       | content-script                              | popup-js                                          | background-js                                     |
| --------------- | ------------------------------------- | ------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| injected-script | -                                     | window.postMessage                          | -                                                 | -                                                 |
| content-script  | window.postMessage                    | -                                           | chrome.runtime.sendMessage chrome.runtime.connect | chrome.runtime.sendMessage chrome.runtime.connect |
| popup-js        | -                                     | chrome.tabs.sendMessage chrome.tabs.connect | -                                                 | chrome.extension. getBackgroundPage()             |
| background-js   | -                                     | chrome.tabs.sendMessage chrome.tabs.connect | chrome.extension.getViews                         | -                                                 |
| devtools-js     | chrome.devtools. inspectedWindow.eval | -                                           | chrome.runtime.sendMessage                        | chrome.runtime.sendMessage                        |

##### popup和background

```
popup可以直接调用background中的JS方法，也可以直接访问background的DOM：

// background.js
function test()
{
	alert('我是background！');
}

// popup.js
var bg = chrome.extension.getBackgroundPage();
bg.test(); // 访问bg的函数
alert(bg.document.body.innerHTML); // 访问bg的DOM
小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。

至于background访问popup如下（前提是popup已经打开）：

var views = chrome.extension.getViews({type:'popup'});
if(views.length > 0) {
	console.log(views[0].location.href);
}
```

##### popup或者bg向content主动发送消息

```
background.js或者popup.js：

function sendMessageToContentScript(message, callback)
{
	chrome.tabs.query({active: true, currentWindow: true}, function(tabs)
	{
		chrome.tabs.sendMessage(tabs[0].id, message, function(response)
		{
			if(callback) callback(response);
		});
	});
}
sendMessageToContentScript({cmd:'test', value:'你好，我是popup！'}, function(response)
{
	console.log('来自content的回复：'+response);
});
content-script.js接收：

chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)
{
	// console.log(sender.tab ?"from a content script:" + sender.tab.url :"from the extension");
	if(request.cmd == 'test') alert(request.value);
	sendResponse('我收到了你的消息！');
});
双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。

网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。
```

##### content-script主动发消息给后台

```
content-script.js：

chrome.runtime.sendMessage({greeting: '你好，我是content-script呀，我主动发消息给后台！'}, function(response) {
	console.log('收到来自后台的回复：' + response);
});
background.js 或者 popup.js：

// 监听来自content-script的消息
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)
{
	console.log('收到来自content-script的消息：');
	console.log(request, sender, sendResponse);
	sendResponse('我是后台，我已收到你的消息：' + JSON.stringify(request));
});
注意事项：

content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转；
如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；
```

#####  injected script和content-script

```
content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：

可以通过window.postMessage和window.addEventListener来实现二者消息通讯；
通过自定义DOM事件来实现；
第一种方法（推荐）：

injected-script中：

window.postMessage({"test": '你好！'}, '*');
content script中：

window.addEventListener("message", function(e)
{
	console.log(e.data);
}, false);
第二种方法：

injected-script中：

var customEvent = document.createEvent('Event');
customEvent.initEvent('myCustomEvent', true, true);
function fireCustomEvent(data) {
	hiddenDiv = document.getElementById('myCustomEventDiv');
	hiddenDiv.innerText = data
	hiddenDiv.dispatchEvent(customEvent);
}
fireCustomEvent('你好，我是普通JS！');
content-script.js中：

var hiddenDiv = document.getElementById('myCustomEventDiv');
if(!hiddenDiv) {
	hiddenDiv = document.createElement('div');
	hiddenDiv.style.display = 'none';
	document.body.appendChild(hiddenDiv);
}
hiddenDiv.addEventListener('myCustomEvent', function() {
	var eventData = document.getElementById('myCustomEventDiv').innerText;
	console.log('收到自定义事件消息：' + eventData);
});
```

#### 长连接和短连接

```
其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。

短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。

短连接上面已经有代码示例了，这里只讲一下长连接。

popup.js：

getCurrentTabId((tabId) => {
	var port = chrome.tabs.connect(tabId, {name: 'test-connect'});
	port.postMessage({question: '你是谁啊？'});
	port.onMessage.addListener(function(msg) {
		alert('收到消息：'+msg.answer);
		if(msg.answer && msg.answer.startsWith('我是'))
		{
			port.postMessage({question: '哦，原来是你啊！'});
		}
	});
});
content-script.js：

// 监听长连接
chrome.runtime.onConnect.addListener(function(port) {
	console.log(port);
	if(port.name == 'test-connect') {
		port.onMessage.addListener(function(msg) {
			console.log('收到长连接消息：', msg);
			if(msg.question == '你是谁啊？') port.postMessage({answer: '我是你爸！'});
		});
	}
});
```

#### 动态注入或执行JS

```
虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。

示例manifest.json配置：

{
	"name": "动态JS注入演示",
	...
	"permissions": [
		"tabs", "http://*/*", "https://*/*"
	],
	...
}
JS：

// 动态执行JS代码
chrome.tabs.executeScript(tabId, {code: 'document.body.style.backgroundColor="red"'});
// 动态执行JS文件
chrome.tabs.executeScript(tabId, {file: 'some-script.js'});
```

#### 动态注入CSS

```
示例manifest.json配置：

{
	"name": "动态CSS注入演示",
	...
	"permissions": [
		"tabs", "http://*/*", "https://*/*"
	],
	...
}
JS代码：

// 动态执行CSS代码，TODO，这里有待验证
chrome.tabs.insertCSS(tabId, {code: 'xxx'});
// 动态执行CSS文件
chrome.tabs.insertCSS(tabId, {file: 'some-style.css'});
```



#### omnibox搜索建议

```
注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。

首先，配置文件如下：

{
	// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字
	"omnibox": { "keyword" : "go" },
}


然后background.js中注册监听事件：

// omnibox 演示
chrome.omnibox.onInputChanged.addListener((text, suggest) => {
	console.log('inputChanged: ' + text);
	if(!text) return;
	if(text == '美女') {
		suggest([
			{content: '中国' + text, description: '你要找“中国美女”吗？'},
			{content: '日本' + text, description: '你要找“日本美女”吗？'},
			{content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'},
			{content: '韩国' + text, description: '你要找“韩国美女”吗？'}
		]);
	}
	else if(text == '微博') {
		suggest([
			{content: '新浪' + text, description: '新浪' + text},
			{content: '腾讯' + text, description: '腾讯' + text},
			{content: '搜狐' + text, description: '搜索' + text},
		]);
	}
	else {
		suggest([
			{content: '百度搜索 ' + text, description: '百度搜索 ' + text},
			{content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text},
		]);
	}
});

// 当用户接收关键字建议时触发
chrome.omnibox.onInputEntered.addListener((text) => {
    console.log('inputEntered: ' + text);
	if(!text) return;
	var href = '';
    if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&ie=utf-8&word=' + text;
	else if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&wd=' + text.replace('百度搜索 ', '');
	else if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', '');
	else href = 'https://www.baidu.com/s?ie=UTF-8&wd=' + text;
	openUrlCurrentTab(href);
});
// 获取当前选项卡ID
function getCurrentTabId(callback)
{
	chrome.tabs.query({active: true, currentWindow: true}, function(tabs)
	{
		if(callback) callback(tabs.length ? tabs[0].id: null);
	});
}

// 当前标签打开某个链接
function openUrlCurrentTab(url)
{
	getCurrentTabId(tabId => {
		chrome.tabs.update(tabId, {url: url});
	})
}
```

#### 本地存储

```
本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是：

chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到；
chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；
需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下：

// 读取数据，第一个参数是指定要读取的key以及设置默认值
chrome.storage.sync.get({color: 'red', age: 18}, function(items) {
	console.log(items.color, items.age);
});
// 保存数据
chrome.storage.sync.set({color: 'blue'}, function() {
	console.log('保存成功！');
});
```



## 前端框架

#### Material-UI

```
npm install @material-ui/core
npm install @mui/material
npm start
npm i prop-types
找不到prop-types可以试试这个

```



## 设计模式

### 概述

```
js的4种设计模式
4种js设计模式

模块模式（module）

原型模式(prototype)

观察者模式(observer)

单例模式(singleton)

模块模式

模块模式是js种最被常用的设计模式，可以使特定部分的代码与其他部分的代码相对独立，通过松散的耦合支撑了良好的代码结构

可以解决的问题:1.封装---可以避免自身的状态和行为被其他模块获取2.模块应该是立即执行函数也就是闭包，闭包之外的代码不能获取这些私有变量，因为他们不在一个作用域

揭示模块设计模型

是模块设计模型的一个变种

目的：在保有封装的前提下，在返回的对象字面上暴露特定变量和方法

带来的问题（缺点）1.不能引用私有方法，给测试带来麻烦2.公共行为不可覆盖

二、原型设计模式（prototype）

原型设计模式依赖于js原型继承

原型模式主要用于在性能密集的条件下创建对象。

通过传递员是对象的克隆（浅客隆）来创建对象

例：执行数据库操作去创建一个对象，如果另一个应用要使用这个对象，只需要去克隆之前的那个对象即可不需要对这个数据库操作

如何去克隆一个对象构造器去实例化一个对象，使用prototype，绑定变量和方法

三 观察者模式

如果一个对象改变了，它会对依赖他的对象进行告知，告诉他有变化发生了

subject，observer，concret对象都是必要的对象。 subject包含了到observer和concret的引用，从而能够通知任何变化，observer是一个抽象的类，可以允许观察者实现通知的方法

缺点：当观察者增多的时候性能会有显著下降

单例模式

单例模式只允许单次实例化，单例模式组织了客户端创建多个实例，一个对象被创建了后，会返回自己的实例


Vue

Vue属于MV*架构模式

Vue准确说是MVC模式，

M:model(模型)

V:view（视图）

C（控制器）

MCV

也就是说model数据和view视图不能直接交互，需要中间环节也就是C（控制器）去实现数据体现在界面的桥梁

```

### MVC、MVP、MVVM模式的概念与区别

```
这些模式是依次进化而形成MVC/MVP—>MVVM。在以前传统的开发模式当中即MVC模式，前端人员只负责Model（数据库） View（视图） Controller /Presenter/ViewModel（控制器） 当中的View（视图）部分，写好页面交由后端创建渲染模板并提供数据，随着MVVM模式的出现前端已经可以自己写业务逻辑以及渲染模板，后端只负责提供数据即可，前端所能做的事情越来越多，这并非坏事，我们的能力得到了提升

MVVM实现了view与model的自动同步，也就是model属性改变的时候， 我们不需要再自己手动操作dom元素去改变view的显示，而是改变属性后该属性对应的view层会自动改变。


说到MVVM就要说一下双向绑定和数据劫持的原理，

1、双向绑定的原理是什么？
（当视图改变的时候更新模型层，当模型层改变的时候更新视图层）
vue中采用了数据劫持&订阅发布模式：
vue在创建vm的时候，会将数据配置在实例当中，然后会使用Object.defineProperty对这些数据进行处理，为这些数据添加getter与setter方法。当获取数据的时候，会触发对应的getter方法，当设置数据的时候，会触发对应的setter方法，从而进一步触发vm上的watcher方法，然后数据了，vm进一步去更新视图。

2、 数据劫持：

vue.js 则是采用数据劫持结合发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的setter，getter。在数据变动时发布消息给订阅者，触发响应的监听回调。

//Object.defineProperty  因为使用了ES5的很多特性 
        let _data = {}
        let middle = 111;
        Object.defineProperty(_data,"msg",{
            get(){
                return middle;
            },
            set(val){
               middle = val;
            }
        });
 
        console.log(_data.msg);//获取数据的时候，会调用对应对象属性的getter方法
        _data.msg = 222;//设置数据的时候，会调用对应对象属性的setter方法
        console.log(_data.msg);

```

### mvc的写法

```
     html:

<div id="box">
        <button class="btn">toggle</button>
        <button class="btn2">big</button>
        <div class="box">
 
        </div>
    </div>
    
    
    下面是我们不用设计模式写的JS，这种写法不利于维护，纯粹的面向过程去写代码：

        let btn = document.getElementsByClassName("btn")[0];
        let boxDom = document.getElementsByClassName("box")[0];
        let flag = true;
        btn.onclick = function(){
            if(flag){
                boxDom.style.display = "none";
                flag = false;
            }else{
                boxDom.style.display = "block";
                flag = true;
            }
        }
        
        ==============================================
     
     //view
        let boxDom = document.getElementsByClassName("box")[0];
        //model
        let model = {
            isShow:true,
            isBig:false
        }
 
        //controller 业务逻辑
        function Controller(){
            this.init();//初始化
        }
        Controller.prototype = {
            constructor:Controller,
            init:function(){
                this.addEvent()
            },
            addEvent:function(){
                let btn = document.getElementsByClassName("btn")[0];
                let btn2 = document.getElementsByClassName("btn2")[0];
                let that = this;
                btn.onclick = function(){
                    model.isShow = !model.isShow;
                    //更改视图了
                    that.render();
                }
                btn2.onclick = function(){
                    model.isBig = true;
                    //更改视图了
                    that.render();
                }
            },
            render:function(){//数据驱动视图的更改
                boxDom.style.display = model.isShow?"block":"none";
                boxDom.style.width = model.isBig?"300px":"100px";
            }
        }
 
        new Controller();//初始化一下

```

## jquery

### 概述

```

```

### 常见面试

```
jQuery 面试问题和答案
　　JavaScript 是客户端脚本的标准语言，而 jQuery 使得编写 JavaScript 更加简单。你可以只用写几行的jQuery 代码就能实现更多的东西. 它是最长被用到的 JavaScript 库之一，并且现在已经很少有不用jQuery 而使用原生 JavaScript 的新项目了。这对于作为一个 Java web 开发者的你而言意味着你会在一场Java web开发面试中发现许多jQuery的面试问题.

　　早些时候，绝大部分都是 HTTP, HTML, CSS 以及 JavaScript，但最近开始，除了 JavaScript 基础之外，人们也希望知道你是否熟悉 jQuery。这16个jQuery的问题是为web开发者准备的，且也能够非常方便你在参加一次电话或者视频一轮的面试之前纠正一些关键的概念。如果你是  jQuery 新手，那么它也能够帮助你更加好的理解基础知识，并激励你去发现更多东西。

　　1. jQuery 库中的 $() 是什么？（答案如下）
　　$() 函数是 jQuery() 函数的别称，乍一看这很怪异，还使 jQuery 代码晦涩难懂。一旦你适应了，你会爱上它的简洁。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你甚至可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。这个问题我已经见过好几次被提及，尽管它非常基础，它经常被用来区分一个开发人员是否了解 jQuery。

　　2. 网页上有 5 个 <div> 元素，如何使用 jQuery来选择它们？（答案）
　　另一个重要的 jQuery 问题是基于选择器的。jQuery 支持不同类型的选择器，例如 ID 选择器、class 选择器、标签选择器。鉴于这个问题没提到 ID 和 class，你可以用标签选择器来选择所有的 div 元素。jQuery 代码：$("div")，这样会返回一个包含所有 5 个 div 标签的 jQuery 对象。更详细的解答参见上面链接的文章。

　　3. jQuery 里的 ID 选择器和 class 选择器有何不同？（答案）
　　如果你用过 CSS，你也许就知道 ID 选择器和 class 选择器之间的差异，jQuery 也同样如此。ID 选择器使用 ID 来选择元素，比如 #element1，而 class 选择器使用 CSS class 来选择元素。当你只需要选择一个元素时，使用 ID 选择器，而如果你想要选择一组具有相同 CSS class 的元素，就要用 class 选择器。在面试过程中，你有很大几率会被要求使用 ID 选择器和 class 选择器来写代码。下面的 jQuery 代码使用了 ID 选择器和 class 选择器：

1
2
$('#LoginTextBox')  // Returns element wrapped as jQuery object with id='LoginTextBox'
$('.active') // Returns all elements with CSS class active.
　　正如你所见，从语法角度来说，ID 选择器和 class 选择器的另一个不同之处是，前者用字符”#”而后者用字符”.”。更详细的分析和讨论参见上面的答案链接。

　　4. 如何在点击一个按钮时使用 jQuery 隐藏一个图片？
　　这是一个事件处理问题。jQuery为按钮点击之类的事件提供了很好的支持。你可以通过以下代码去隐藏一个通过ID或class定位到的图片。你需要知道如何为按钮设置事件并执行hide() 方法，代码如下所示：

1
2
3
$('#ButtonToClick').click(function(){
    $('#ImageToHide').hide();
});
　　5.  $(document).ready() 是个什么函数？为什么要用它？(answer)
　　这个问题很重要，并且常常被问到。 ready() 函数用于在文档进入ready状态时执行代码。当DOM 完全加载（例如HTML被完全解析DOM树构建完成时），jQuery允许你执行代码。使用$(document).ready()的最大好处在于它适用于所有浏览器，jQuery帮你解决了跨浏览器的难题。需要进一步了解的用户可以点击 answer链接查看详细讨论。

　　6. JavaScript window.onload 事件和 jQuery ready 函数有何不同？（答案）
　　这个问答是紧接着上一个的。JavaScript window.onload 事件和 jQuery ready 函数之间的主要区别是，前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。

　　另一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。

　　7. 如何找到所有 HTML select 标签的选中项？（答案如下）
　　这是面试里比较棘手的 jQuery 问题之一。这是个基础的问题，但是别期望每个 jQuery 初学者都知道它。你能用下面的 jQuery 选择器获取所有具备 multiple=true 的 <select > 标签的选中项：

1
$('[name=NameOfSelectedTag] :selected')
　　这段代码结合使用了属性选择器和 :selected 选择器，结果只返回被选中的选项。你可按需修改它，比如用 id 属性而不是 name 属性来获取 <select> 标签。

　　8. jQuery 里的 each() 是什么函数？你是如何使用它的？（答案如下）
　　each() 函数就像是 Java 里的一个 Iterator，它允许你遍历一个元素集合。你可以传一个函数给 each() 方法，被调用的 jQuery 对象会在其每个元素上执行传入的函数。有时这个问题会紧接着上面一个问题，举个例子，如何在 alert 框里显示所有选中项。我们可以用上面的选择器代码找出所有选中项，然后我们在 alert 框中用 each() 方法来一个个打印它们，代码如下：

1
2
3
$('[name=NameOfSelectedTag] :selected').each(function(selected) {
    alert($(selected).text());
});
　　其中 text() 方法返回选项的文本。

　　9. 你是如何将一个 HTML 元素添加到 DOM 树中的？（答案如下）
　　你可以用 jQuery 方法 appendTo() 将一个 HTML 元素添加到 DOM 树中。这是 jQuery 提供的众多操控 DOM 的方法中的一个。你可以通过 appendTo() 方法在指定的 DOM 元素末尾添加一个现存的元素或者一个新的 HTML 元素。

　　10. 你能用 jQuery 代码选择所有在段落内部的超链接吗？（答案略）
　　你可以使用下面这个 jQuery 代码片段来选择所有嵌套在段落（<p>标签）内部的超链接（<a>标签）

                             $( 'p a' );

　　11. $(this) 和 this 关键字在 jQuery 中有何不同？（答案如下）
　　这对于很多 jQuery 初学者来说是一个棘手的问题，其实是个简单的问题。$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。

　　12. 你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href? (答案)
　　attr() 方法被用来提取任意一个HTML元素的一个属性的值. 你首先需要利用jQuery选择及选取到所有的链接或者一个特定的链接，然后你可以应用attr()方法来获得他们的href属性的值。下面的代码会找到页面中所有的链接并返回href值：

1
2
3
$('a').each(function(){
   alert($(this).attr('href'));
});
　　13. 你如何使用jQuery设置一个属性值? (答案)
　　前面这个问题之后额外的一个后续问题是，attr()方法和jQuery中的其它方法一样，能力不止一样. 如果你在调用attr()的同时带上一个值 。

                  对象.attr("name","value")；name是属性的名称，value是这个属性的新值

                  对象.prop("name","value");

       设置多个属性值：对象.attr("name":"value","name":"value")属性：属性值，属性：属性值

　　jquery中attr和prop的区别
                   对于html元素本身就带有的固定属性（本身就带有的属性），在处理时，使用prop方法  可以操作布尔类型的属性

                   对于html元素我们自己定义的dom属性，在处理时，使用attr方法   不可以操作布尔类型的属性

                   <a href = "#" id="link1" class="btn" action="delete">删除</a>

                 这个例子里的<a>元素的dom属性值有"id、href、class和action"，很明显，前三个是固有属性，而后面一个action属性是我们自己定义上去的

                 <a>元素本身是没有属性的。这种就是自定义的dom属性。处理这些属性时，建议使用attr方法，使用prop方法对自定义属性取值和设置属性值时，都会返回undefined值。

                 像checkbox，radio和select这样的元素，选中属性对应“checked”和"selected"，这些也属于固有属性，因此需要使用prop方法去操作才能获取正确答案

                                                

 

       14. jQuery中 detach() 和 remove() 方法的区别是什么? (答案)
　　尽管 detach() 和 remove() 方法都被用来移除一个DOM元素, 两者之间的主要不同在于 detach() 会保持对过去被解除元素的跟踪, 因此它可以被取消解除, 而 remove() 方法则会保持过去被移除对象的引用. 你也还可以看看 用来向DOM中添加元素的 appendTo() 方法.

　　15. 你如何利用jQuery来向一个元素中添加和移除CSS类? (答案)
　　通过利用 addClass() 和 removeClass() 这两个 jQuery 方法。动态的改变元素的class属性可以很简单例如. 使用类“.active"来标记它们的未激活和激活状态，等等

                .addClass("类名")添加元素      .remove()  删除样式类   

　　16. 使用 CDN 加载 jQuery 库的主要优势是什么 ? (答案)
　　这是一个稍微高级点儿的jQuery问题。好吧，除了报错节省服务器带宽以及更快的下载速度这许多的好处之外, 最重要的是，如果浏览器已经从同一个CDN下载类相同的 jQuery 版本, 那么它就不会再去下载它一次. 因此今时今日，许多公共的网站都将jQuery用于用户交互和动画, 如果浏览器已经有了下载好的jQuery库，网站就能有非常好的展示机会。

　　17.  jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?
　　ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。get() 方法是一个只获取一些数据的专门化方法。

　　18. jQuery 中的方法链是什么？使用方法链有什么好处？
　　方法链是对一个方法返回的结果调用另一个方法，这使得代码简洁明了，同时由于只对 DOM 进行了一轮查找，性能方面更加出色。

　　19. 你要是在一个 jQuery 事件处理程序里返回了 false 会怎样？
　　这通常用于阻止事件向上冒泡。

　　20. 哪种方式更高效：document.getElementbyId("myId") 还是 $("#myId")？
 

　　第一种，因为它直接调用了 JavaScript 引擎。
```



## angular

### 概述

```

```

### AngularJS 的数据双向绑定

```
angular 的数据绑定采用什么机制？详述原理

答案：脏检查机制。

解析：
双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。

原理就是，Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。
```

### 发请求

```
import { Component, OnInit } from '@angular/core';
import {HttpClient} from '@angular/common/http';

@Component({
  selector: 'post',
  templateUrl: './post.component.html',
  styleUrls: ['./post.component.css']
})


export class PostComponent {
  private url = 'http://jsonplaceholder.typicode.com/posts';
  myData: any[];
  constructor(private http: HttpClient){
    http.get(this.url)
      .subscribe(response=>{
        this.myData = response as any[];
      })
  } 
  constructor(private http: HttpClient){}
  submit(data){
    this.http.post(this.url, data)
      .subscribe(result=>{
        console.log("Result", result);
      });
  }
}



import { Injectable, Injector, EventEmitter } from '@angular/core';
import { Http, Response, Headers } from '@angular/http';
import { URLSearchParams, Jsonp } from '@angular/http';
import { Observable } from 'rxjs';
@Injectable()
export class RequestService {
    private http: Http;
    constructor(
        private injector: Injector
    ) {
        this.http = injector.get(Http);
    }
    handleError(error: Response | any): boolean {
        console.error("baseService received request errorr");
        console.log(error);
        let errMsg: string;
        if (error instanceof Response) {
            const body = error.json() || '';
            const err = body.error || JSON.stringify(body);
            errMsg = `${error.status} - ${error.statusText || ''} ${err}`;
        } else {
            errMsg = error.message ? error.message : error.toString();
        }
        Observable.throw(errMsg);
        return false;
    }
    createRequstParam(data: any, jsonp = false): any {
        let params = new URLSearchParams();
        for (let key in data) {
            params.set(key, data[key])
        }
        // if (jsonp == true) {
        //     params.set('callback', 'JSONP_CALLBACK');
        // }
        return params;
    }
    createHeaders() {
        let headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        return headers;
    }
    checkResponeCode(res: Response) {
        let serverResponse = res.json() as { code: number, desc: string, data: any };

        return serverResponse;
    }
    queryServer(query: { url: string, method: string }, param: any): Promise<any> {
        let form = this.createRequstParam(param);
        switch (query.method) {
            case "post":
                return this.http.post(query.url, form, { headers: this.createHeaders() }).toPromise().then(this.checkResponeCode.bind(this)).catch(this.handleError);
            case "get":
            default:
                return this.http.get(query.url, { search: form }).toPromise().then(this.checkResponeCode.bind(this)).catch(this.handleError);
        }
    }
}
```



### angular常见面试

```
1.angular 的数据绑定采用什么机制？详述原理

答案：脏检查机制。

解析：
双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。

原理就是，Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。

参与互动

2.AngularJS 的数据双向绑定是怎么实现的？

答案：

1、每个双向绑定的元素都有一个 watcher

2、在某些事件发生的时候，调用 digest 脏数据检测。

这些事件有：表单元素内容变化、Ajax 请求响应、点击按钮执行的函数等。

3、脏数据检测会检测 rootscope 下所有被 watcher 的元素。

$digest 函数就是脏数据监测

参与互动

3.在使用 angularjs 项目开发中 你使用过那些第三方的插件

答案：AngularUi ui-router oclazyload 等等 附上一篇文章仔细去看看 https://segmentfault.com/a/1190000003858219

参与互动

4.ng-show/ng-hide 与 ng-if 的区别？

答案：我们都知道 ng-show/ng-hide 实际上是通过 display 来进行隐藏和显示的。而 ng-if 实际上控制 dom 节点的增删除来实现的。因此如果我们是根据不同的条件来进行 dom 节点的加载的话，那么 ng-if 的性能好过 ng-show.

参与互动

5.解释下什么是r o o t S c r o p e 以 及 和 rootScrope以及和rootScrope以及和scope 的区别？

答案：通俗的说r o o t S c r o p e 页 面 所 有 rootScrope 页面所有rootScrope页面所有scope 的父亲。

解析：

我们来看下如何产生r o o t S c o p e 和 rootScope和rootScope和scope 吧。

step1:Angular 解析 ng-app 然后在内存中创建$rootScope。

step2:angular 回继续解析，找到{undefined{}}表达式，并解析成变量。

step3:接着会解析带有 ng-controller 的 div 然后指向到某个 controller 函数。 这个时候在这个 controller 函数变成一个$scope 对象实例。

参与互动

6.列出至少三种实现不同模块之间通信方式？

答案：

Service
events,指定绑定的事件
使用 $rootScope
controller 之间直接使用$parent, $$childHead 等
directive 指定属性进行数据绑定
参与互动

7. 表达式 {{yourModel}} 是如何工作的？

答案：

它依赖于 $interpolation服务，在初始化页面html后，它会找到这些表达式，并且进行标记，于是每遇见一个 {undefined{}} ，则会设置一个 $watch 。而 $interpolation 会返回一个带有上下文参数的函数，最后该函数执行，则算是表达式 $parse 到那个作用域上。

参与互动

8.angular 中的$http

答案：$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。

我们可以使用内置的h t t p 服 务 直 接 同 外 部 进 行 通 信 。 http服务直接同外部进行通信。http服务直接同外部进行通信。http 服务只是简单的封装了浏览器原生的 XMLHttpRequest 对象。

参与互动

9.ng-repeat 迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？

答案：会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）

参与互动

10.angularjs 是 mvc 还是 mvvm 框架

答案：mvvm

解析：

首先阐述下你对 mvc 和 mvvm 的理解:

首先为什么我们会需要 MVC？因为随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而 MVC 只是手段，终极目标是模块化和复用。

mvvm 的优点

低耦合：View 可以独立于 Model 变化和修改，同一个 ViewModel 可以被多个 View 复用；并且可以做到 View 和 Model 的变化互不影响；

可重用性：可以把一些视图的逻辑放在 ViewModel，让多个 View 复用；

独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi 计人员可以专注于 UI(View)的设计；

可测试性：清晰的 View 分层，使得针对表现层业务逻辑的测试更容易，更简单。

在 angular 中 MVVM 模式主要分为四部分：

View：它专注于界面的显示和渲染，在 angular 中则是包含一堆声明式 Directive 的视图模板。

ViewModel：它是 View 和 Model 的粘合体，负责 View 和 Model 的交互和协作，它负责给 View 提供显示的数据，以及提供了 View 中 Command 事件操作 Model 的途径；在 angular 中$scope 对象充当了这个 ViewModel 的角色；

Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model 并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在 web 页面中，大部分 Model 都是来自 Ajax 的服务端返回数据或者是全局的配置对象；而 angular 中的 service 则是封装和处理这些与 Model 相关的业务逻辑的场所，这类的业务服务是可以被多个 Controller 或者其他 service 复用的领域服务。

Controller：这并不是 MVVM 模式的核心元素，但它负责 ViewModel 对象的初始化，它将组合一个或者多个 service 来获取业务领域 Model 放在 ViewModel 对象上，使得应用界面在启动加载的时候达到一种可用的状态。

mvc 的界面和逻辑关联紧密，数据直接从数据库读取。mvvm 的界面与 viewmode 是松耦合，界面数据从 viewmodel 中获取。所以 angularjs 更倾向于 mvvm

参与互动

11.angularjs 中$scope，controller，directive，sevice 在 mvvm 中充当什么角色

答案：如果你不知道，第一题的分析以及很明确，仔细再仔细的看一遍

参与互动

12.在 angular 项目中你如何控制静态资源的合理加载

答案：

参与互动

13.在写 controlloer 逻辑的时候 你需要注意什么？

答案：

1.简化代码（这个是所有开发人员都要具备的）

2.坚决不能操作 dom 节点 这个时候可能会问 为什么不能啊

你的回答是：DOM 操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular 倡导以测试驱动开发，在 service 或者 controller 中出现了 DOM 操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用 Angular 的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的 DOM 操作。如果在 Angular 的代码中还到处充斥着各种 DOM 操作，那为什么不直接使用 jquery 去开发呢。

测试驱动开发是什么呢？普及一下：

测试驱动开发，英文全称 Test-Driven Development，简称 TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。

参与互动

14.controller 之间怎么通讯

答案：

1、event

这里可以有两种方式，一种是s c o p e . scope.scope.emit，然后通过监听r o o t S c o p e 的 事 件 获 取 参 数 ； 另 一 种 是 rootScope的事件获取参数；另一种是rootScope的事件获取参数；另一种是rootScope.b r o a d c a s t ， 通 过 监 听 broadcast，通过监听broadcast，通过监听scope 的事件获取参数。

这两种方法在最新版本的 Angular 中已经没有性能区别了，主要就是事件发送的方向不同，可以按实际情况选择。

2、service

可以创建一个专用的事件 Service，也可以按照业务逻辑切分，将数据存储在相应的 Service 中

3、$rootScope

这个方法可能会比较 dirty 一点，胜在方便，也就是把数据存在r o o t S c o p e 中 ， 这 样 各 个 子 rootScope中，这样各个子rootScope中，这样各个子scope 都可以调用，不过需要注意一下生命周期

4、直接使用s c o p e . scope.scope.$nextSibling 及类似的属性

类似的还有s c o p e . scope.scope.parent。这个方法的缺点就更多了，官方不推荐使用任何$$开头的属性，既增加了耦合，又需要处理异步的问题，而且 scope 的顺序也不是固定的。不推荐

另外就是通过本地存储、全局变量或者现代浏览器的 postMessage 来传递参数了，除非特殊情况，请避免这类方式。

参与互动

15.自定义指令的几个参数

答案：

说几个常用的如：

restrict:指令在 dom 中的声明形式 E（元素）A（属性）C（类名）M（注释）

template：两种形式，一种 HTML 文本；一个可以接受两个参数的函数，tElemetn 和 tAttrs，并返回一个代表模板的字符串。模板字符串必须存在一个根 DOM 元素

templateUrl:两种形式，一种代表外部 HTML 文件路径的字符串；一个可以接受两个参数的函数，参数为 tElement 和 tAttrs，并返回一个外部 HTML 文件路径的字符串

compile (对象或函数)：compile 选项可以返回一个对象或函数。如果设置了 compile 函数,说明我们希望在指令和实时数据被放到 DOM 中之前进行 DOM 操作,在这个函数中进行诸如添加和删除节点等 DOM 操作是安全的。本质上,当我们设置了 link 选项,实际上是创建了一个 postLink() 链接函数,以便 compile() 函数可以定义链接函数。

然后又是传送门：http://www.cnblogs.com/mliudong/p/4180680.html

compile 和 link 的区别：

编译的时候，compile 转换 dom，碰到绑定监听器的地方就先存着，有几个存几个，到最后汇总成一个 link 函数，一并执行，提升了性能。

参与互动

16.angular 和 jquery 的区别

答案：

angular 是基于数据驱动，所以 angular 适合做数据操作比较繁琐的项目（这里可以再提一下单页面应用，如果你不会福利又来了 http://www.zhihu.com/question/20792064）

jquery 是基于 dom 驱动，jquery 适合做 dom 操作多的项目

参与互动

17.对 angular 中的 form 表单了解多少

答案：

Angular 对 input 元素的 type 进行了扩展，一共提供了以下 10 种类型：

text

number

url

email

radio

checkbox

hidden

button

submit

reset

Angular 为表单内置了 4 中 CSS 样式。

ng-valid 校验合法状态

ng-invalid 校验非法状态

ng-pristine 如果要使用原生的 form，需要设置这个值

ng-dirty 表单处于脏数据状态

Angular 在对表单进行自动校验的时候会校验 Model 上的属性，如果不设置 ng-model，则 Angular 无法知道 myForm.$invalid 这个值是否为真。

校验的一下内容

required 表示是否输入内容

ng-maxlength 最大长度

ng-minlength 最小长度

例子：传送门https://github.com/18500047564/clutter

参与互动

18.fliter 是什么你了解的有多少？实现一个自定义 fliter

答案：

date（日期）

currency（货币）

limitTo（限制数组或字符串长度）

orderBy（排序）

lowercase（小写）

uppercase（大写）

number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）

filter（处理一个数组，过滤出含有某个子串的元素）

json（格式化 json 对象）

filter 有两种使用方法，

一种是直接在页面里：

<p>{{now | date : ‘yyyy-MM-dd’}}</p>
1
另一种是在 js 里面用：

$filter(‘过滤器名称’)(需要过滤的对象, 参数 1, 参数 2,…)

$filter(‘date’)(now, 'yyyy-MM-dd hh:mm:ss’);

自定义一个去重数组的

app.filter("unique", function() {
  return function(arr) {
    var n = [];
    var obj = {};

    for (var i = 0; i < arr.length; i++) {
      if (!obj[arr[i]]) {
        n.push(arr[i]);
        obj[arr[i]] = 1;
      }
    }

    return n;
  };
});
```



## vue

### 概述

```

```

### 指令

```
v-text 只能用在双标签中
 v-text 其实就是给元素的innerText赋值
 v-html 其实就是给元素的innerHTML赋值
 v-if 如果值为false,会留下一个<!---->作为标记，万一未来v-if的值是true了，就在这里插入元素
 如果有if和else就不需要单独留坑了
 如果全用上  v-if 相邻v-else-if 相邻 v-else 否则 v-else-if可以不用
 v-if和v-else-if都有等于对应的值，而v-else直接写
 v-if家族都是对元素进行插入和移除的操作
 v-show是显示与否的问题
 注意: 指令其实就是利用属性作为标识符,简化DOM操作,
  看：v-model="xxx"
  v-model 代表要做什么  xxx代表针对的js内存对象
  写在那个元素上，就对哪个元素操作
  
  
  v-bind使用
给元素的属性赋值 <div file="{{变量}}"></div>
可以给已经存在的属性赋值 input value
也可以给自定义属性赋值 mydata


语法 在元素上 v-bind:属性名="常量||变量名"
简写形式 :属性名="变量名"
<div v-bind:原属性名="变量"></div>
<div :属性名="变量">

</div>
dsad

更便捷的操作DOM及数据 v-xxx指令
v-text/v-html/v-if/v-show/v-bind/v-on
v-bind绑定属性值
v-on绑定事件

input v-model="name"
双向数据绑定 页面对于input的value改变，能影响内存中name变量
内存js改变name的值，会影响页面重新渲染最新值


input :value="name"
单向数据绑定 内存改变影响页面改变


v-model: 其的改变影响其他 v-bind: 其的改变不影响其他
v-bind就是对属性的简单赋值,当内存中值改变，还是会触发重新渲染

```



### vue双向数据绑定

```
它最大的特性就是数据的双向绑定以及虚拟dom.核心就是用数据来驱动视图层的改变.先看一段代码.

二、实现原理
vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的.
1）数据劫持、vue是通过Object.defineProperty()来实现数据劫持，其中会有getter()和setter方法；当读取属性值时，就会触发getter()方法，在view中如果数据发生了变化，就会通
过Object.definePr
operty( )对属性设置一个setter函数，当数据改变了就会来触发这个函数；


我们知道可以利用Obeject.defineProperty()来监听属性变动
那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样：


几种实现双向绑定的做法
目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。

实现数据绑定的做法有大致如下几种：

发布者-订阅者模式（backbone.js）

脏值检查（angular.js）

数据劫持（vue.js）

发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set('property', value)，这里有篇文章讲的比较详细，有兴趣可点这里

这种方式现在毕竟太low了，我们更希望通过 vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式

脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：

DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
XHR响应事件 ( $http )
浏览器Location变更事件 ( $location )
Timer事件( interval )
执行 apply()


数据劫持: 
vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。vue3.0之后开始使用proxy实现对象的监听，避免了definePropety需要递归添加监听的问题。


```

```
1、实现Observer
ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let's do it
我们知道可以利用Obeject.defineProperty()来监听属性变动
那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样：

var data = {name: 'kindeng'};
observe(data);
data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --> dmq

function observe(data) {
    if (!data || typeof data !== 'object') {
        return;
    }
    // 取出所有属性遍历
    Object.keys(data).forEach(function(key) {
        defineReactive(data, key, data[key]);
    });
};

function defineReactive(data, key, val) {
    observe(val); // 监听子属性
    Object.defineProperty(data, key, {
        enumerable: true, // 可枚举
        configurable: false, // 不能再define
        get: function() {
            return val;
        },
        set: function(newVal) {
            console.log('哈哈哈，监听到值变化了 ', val, ' --> ', newVal);
            val = newVal;
        }
    });
}
这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样：

// ... 省略
function defineReactive(data, key, val) {
    var dep = new Dep();
    observe(val); // 监听子属性

    Object.defineProperty(data, key, {
        // ... 省略
        set: function(newVal) {
            if (val === newVal) return;
            console.log('哈哈哈，监听到值变化了 ', val, ' --> ', newVal);
            val = newVal;
            dep.notify(); // 通知所有订阅者
        }
    });
}

function Dep() {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？
没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚：

// Observer.js
// ...省略
Object.defineProperty(data, key, {
    get: function() {
        // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除
        Dep.target && dep.addDep(Dep.target);
        return val;
    }
    // ... 省略
});

// Watcher.js
Watcher.prototype = {
    get: function(key) {
        Dep.target = this;
        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者
        Dep.target = null;
    }
}
这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了

2、实现Compile
compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示：
图片描述

因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中

function Compile(el) {
    this.$el = this.isElementNode(el) ? el : document.querySelector(el);
    if (this.$el) {
        this.$fragment = this.node2Fragment(this.$el);
        this.init();
        this.$el.appendChild(this.$fragment);
    }
}
Compile.prototype = {
    init: function() { this.compileElement(this.$fragment); },
    node2Fragment: function(el) {
        var fragment = document.createDocumentFragment(), child;
        // 将原生节点拷贝到fragment
        while (child = el.firstChild) {
            fragment.appendChild(child);
        }
        return fragment;
    }
};
compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：

Compile.prototype = {
    // ... 省略
    compileElement: function(el) {
        var childNodes = el.childNodes, me = this;
        [].slice.call(childNodes).forEach(function(node) {
            var text = node.textContent;
            var reg = /\{\{(.*)\}\}/;    // 表达式文本
            // 按元素节点方式编译
            if (me.isElementNode(node)) {
                me.compile(node);
            } else if (me.isTextNode(node) && reg.test(text)) {
                me.compileText(node, RegExp.$1);
            }
            // 遍历编译子节点
            if (node.childNodes && node.childNodes.length) {
                me.compileElement(node);
            }
        });
    },

    compile: function(node) {
        var nodeAttrs = node.attributes, me = this;
        [].slice.call(nodeAttrs).forEach(function(attr) {
            // 规定：指令以 v-xxx 命名
            // 如 <span v-text="content"></span> 中指令为 v-text
            var attrName = attr.name;    // v-text
            if (me.isDirective(attrName)) {
                var exp = attr.value; // content
                var dir = attrName.substring(2);    // text
                if (me.isEventDirective(dir)) {
                    // 事件指令, 如 v-on:click
                    compileUtil.eventHandler(node, me.$vm, exp, dir);
                } else {
                    // 普通指令
                    compileUtil[dir] && compileUtil[dir](node, me.$vm, exp);
                }
            }
        });
    }
};

// 指令处理集合
var compileUtil = {
    text: function(node, vm, exp) {
        this.bind(node, vm, exp, 'text');
    },
    // ...省略
    bind: function(node, vm, exp, dir) {
        var updaterFn = updater[dir + 'Updater'];
        // 第一次初始化视图
        updaterFn && updaterFn(node, vm[exp]);
        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher
        new Watcher(vm, exp, function(value, oldValue) {
            // 一旦属性值有变化，会收到通知执行此更新函数，更新视图
            updaterFn && updaterFn(node, value, oldValue);
        });
    }
};

// 更新函数
var updater = {
    textUpdater: function(node, value) {
        node.textContent = typeof value == 'undefined' ? '' : value;
    }
    // ...省略
};
这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如<span v-text="content" other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。
监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知

至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了

3、实现Watcher
Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
如果有点乱，可以回顾下前面的思路整理

function Watcher(vm, exp, cb) {
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解
    this.value = this.get(); 
}
Watcher.prototype = {
    update: function() {
        this.run();    // 属性值变化收到通知
    },
    run: function() {
        var value = this.get(); // 取到最新值
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图
        }
    },
    get: function() {
        Dep.target = this;    // 将当前订阅者指向自己
        var value = this.vm[exp];    // 触发getter，添加自己到属性订阅器中
        Dep.target = null;    // 添加完毕，重置
        return value;
    }
};
// 这里再次列出Observer和Dep，方便理解
Object.defineProperty(data, key, {
    get: function() {
        // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除
        Dep.target && dep.addDep(Dep.target);
        return val;
    }
    // ... 省略
});
Dep.prototype = {
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update(); // 调用订阅者的update方法，通知变化
        });
    }
};
实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。
```

### Vue路由钩子函数

```
beforeEach,afterEach,beforeEnter
```



### vue3与vue2的区别

`HBuilderX 3.3.0+` 更新uni-app编译器，支持基于 Vite 编译到小程序平台。

至此，`uni-app`在`App/H5/小程序`全平台支持`Vue 3.0`开发，且全平台支持`Vite`编译器

1. 创建一个 uni-app 项目
2. 在项目的 manifest 的「基础配置」中切换 「vue 版本选择」，默认是 vue2，切换为 vue3 即可

```
vue2和vue3的区别

一、常用命令

vue -V 查看本地 vue 版本

二、官方文档

3.0：https://cli.vuejs.org/zh/

三、创建文件

3.0：vue create 进入工程文件夹，创建项目。

2.0：vue init webpack

四、启动项目

3.0启动npm run serve

2.0启动npm run dev

build没了、config没了、哦对了还有最重要的一点，3.0的安装项目时自动下载node-model。

在根目录下创建一个vue.config.js


一、默认进行懒观察（lazy observation）。

在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。

二、更精准的变更通知。

比例来说：2.x 版本中，你使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。

三、3.0 新加入了 TypeScript 以及 PWA 的支持

四、部分命令发生了变化：

下载安装 npm install -g vue@cli

删除了vue list

创建项目 vue create

启动项目 npm run serve

五、默认项目目录结构也发生了变化：

移除了配置文件目录，config 和 build 文件夹

移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中

在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件


1. vue2和vue3双向数据绑定原理发生了改变
vue2 的双向数据绑定是利用ES5 的一个 API Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。

vue3 中使用了 es6 的 ProxyAPI 对数据代理。

 

相比于vue2.x，使用proxy的优势如下 　　

1.defineProperty只能监听某个属性，不能对全对象监听，而proxyAPI则可以监听整个对象 　　

2.可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 　　

3.可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化

 

 

2.移除过滤器filters
vue3x删除了filters 并推荐使用computed代替计算属性，在2x中filters和computed有许多相似之处，这个不仅增加了学习成本也增加了维护成本，因此在3.0的中完全摒弃了filters。

 

3.生命周期的变化
移除了beforeCreate（）和Created（）
新增了setup().
在剩余六个函数之前加入了on
在这里插入图片描述

4.支持多节点组件
在2.0中我们需要 在template标签内包一个div来防止用户意外创建多根组件时发出的警告，即

1
2
3
4
5
6
7
<template>
    <div>
        <header></header>
        <main></main>
        <footer></footer>
    </div>
</template>
但在3.0中这样做不是必须的 


结构部分
程序主入口文件 main.js
vue2.0
    import Vue from 'vue'
    import App from './App.vue'
    import router from "./router"
    import store from "./store"
    new Vue({
        store,
        router,
        render: h => h(App),
    }).$mount('#app')
vue3.0-暴露出 createApp方法
    import { createApp } from 'vue';
    import App from './App.vue'

    createApp(App).mount('#app')


```

### 解析Vue2.0和3.0的响应式原理和异同

```
Vue 2.0

Vue2.0实现MVVM(双向数据绑定)的原理是通过 Object.defineProperty 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

Vue 3.0实现响应式基于ES6:Proxy

Vue2.0和Vue3.0的差异如下:

Vue2.0
基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。
Object.defineProperty 无法检测到对象属性的添加和删除 。
由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。
深度监听需要一次性递归，对性能影响比较大。
Vue3.0

基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。
不需要一次性遍历data的属性，可以显著提高性能。
因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。
```

#### Vue2.0

```
function defineReactive(target, key, value) {
   //深度监听
   observer(value);
 
   Object.defineProperty(target, key, {
     get() {
       return value;
     },
     set(newValue) {
       //深度监听
       observer(value);
       if (newValue !== value) {
         value = newValue;
 
         updateView();
       }
     }
   });
 }
 
 function observer(target) {
   if (typeof target !== "object" || target === null) {
     return target;
   }
 
   if (Array.isArray(target)) {
     target.__proto__ = arrProto;
   }
 
   for (let key in target) {
     defineReactive(target, key, target[key]);
   }
 }
 
 // 重新定义数组原型
 const oldAddrayProperty = Array.prototype;
 const arrProto = Object.create(oldAddrayProperty);
 ["push", "pop", "shift", "unshift", "spluce"].forEach(
   methodName =>
     (arrProto[methodName] = function() {
       updateView();
       oldAddrayProperty[methodName].call(this, ...arguments);
     })
 );
 
 // 视图更新
  function updateView() {
   console.log("视图更新");
 }
 
 // 声明要响应式的对象
 const data = {
   name: "zhangsan",
   age: 20,
   info: {
     address: "北京" // 需要深度监听
   },
   nums: [10, 20, 30]
 };
 
 // 执行响应式
 observer(data);
```

#### Vue3.0

```
const proxyData = new Proxy(data, {
   get(target,key,receive){ 
     // 只处理本身(非原型)的属性
     const ownKeys = Reflect.ownKeys(target)
     if(ownKeys.includes(key)){
       console.log('get',key) // 监听
     }
     const result = Reflect.get(target,key,receive)
     return result
   },
   set(target, key, val, reveive){
     // 重复的数据，不处理
     const oldVal = target[key]
     if(val == oldVal){
       return true
     }
     const result = Reflect.set(target, key, val,reveive)
     console.log('set', key, val)
     return result
   },
   deleteProperty(target, key){
     const result = Reflect.deleteProperty(target,key)
     console.log('delete property', key)
     console.log('result',result)
     return result
   }
 })

  // 声明要响应式的对象,Proxy会自动代理
 const data = {
   name: "zhangsan",
   age: 20,
   info: {
     address: "北京" // 需要深度监听
   },
   nums: [10, 20, 30]
 };
```



### 基础

```
<router-link to="/home/computer">电脑</router-link>
```

#### computed

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
<script src="https://unpkg.com/vue@next"></script>
</head>
<body>
<div id="app">
  <p>原始字符串: {{ message }}</p>
  <p>计算后反转字符串: {{ reversedMessage }}</p>
</div>
    
<script>
const app = {
  data() {
    return {
      message: 'RUNOOB!!'
    }
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
}
 
Vue.createApp(app).mount('#app')
</script>
```

#### v-model

```
v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：

  1. v-bind绑定一个value属性

  2. v-on指令给当前元素绑定input事件

自定义组件使用v-model，应该有以下操作：

1. 接收一个value prop

2. 触发input事件，并传入新值


在原生表单元素中：

1
<input v-model="inputValue">
相当于

1
<input v-bind:value="inputValue" v-on:input="inputValue = $event.target.value">
在自定义组件中

1
<my-component v-model="inputValue"></my-component>
相当于

1
<my-component v-bind:value="inputValue" v-on:input="inputValue = argument[0]"></my-component>

这个时候，inputValue接受的值就是input事件的回调函数的第一个参数，所以在自定义组件中，要实现数据绑定，还需要$emit去触发input的事件。

1
this.$emit('input', value)
```



#### v-if v-show

```


vue中显隐方法常用两种，v-show和v-if，但这两种是有区别的。

实现本质方法区别

v-show本质就是标签display设置为none，控制隐藏

v-if是动态的向DOM树内添加或者删除DOM元素

编译的区别

v-show其实就是在控制css

v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件

编译的条件

v-show都会编译，初始值为false，只是将display设为none，但它也编译了

v-if初始值为false，就不会编译了

性能

v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。
```

### mixins

```
vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

与公共组件的区别

同样明显的区别来再列一遍哈~

组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。
==================================

混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

1 方法和参数在各组件中不共享，各自独立

2 值为对象的选项，如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的混入对象中的方法
就是冲突了，跟行内样式一样，以当前组件的为准

3 值为函数的选项，如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用混入对象函数中的console

mixin的created,mounted先输出




```



### nextTick

```
下面了解下nextTick的主要应用的场景及原因。

在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。

在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。
具体原因在Vue的官方文档中详细解释：

Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。

例如，当你设置vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

```



### 监听

```
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script>
  const watchExampleVM = Vue.createApp({
    data() {
      return {
        question: '',
        answer: '每个问题结尾需要输入 ? 号。'
      }
    },
    watch: {
      // 每当问题改变时，此功能将运行，以 ? 号结尾
      question(newQuestion, oldQuestion) {
        if (newQuestion.indexOf('?') > -1) {
          this.getAnswer()
        }
      }
    },
    methods: {
      getAnswer() {
        this.answer = '加载中...'
        axios
          .get('https://yesno.wtf/api')
          .then(response => {
            this.answer = response.data.answer
          })
          .catch(error => {
            this.answer = '错误! 无法访问 API。 ' + error
          })
      }
    }
  }).mount('#watch-example')
</script>
```



### 生命周期

```
生命周期有哪些？beformount里有dom吗？
beforeCreate\created\beforeMount\mounted\beforeUpdate\updated\beforeDestroy\destroyed
mounted里形成真正的dom


得到值的总结

beforeCreate执行时：data和el均未初始化，值为undefined
created执行时：Vue 实例观察的数据对象data已经配置好，已经可以得到data的值，但Vue 实例使用的根 DOM 元素el还未初始化
beforeMount执行时：data和el均已经初始化，但此时el并没有渲染进数据，el的值为“虚拟”的元素节点
mounted执行时：此时el已经渲染完成并挂载到实例上
beforeUpdate和updated触发时，el中的数据都已经渲染完成，但只有updated钩子被调用时候，组件dom才被更新。

============

在created钩子中可以对data数据进行操作，这个时候可以进行数据请求将返回的数据赋给data
在mounted钩子对挂载的dom进行操作，此时，DOM已经被渲染到页面上。
虽然updated函数会在数据变化时被触发，但却不能准确的判断是那个属性值被改变，所以在实际情况中用computed或watch函数来监听属性的变化，并做一些其他的操作。
所有的生命周期钩子自动绑定 this 上下文到实例中，所以不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())，会导致this指向父级。
在使用vue-router时有时需要使用来缓存组件状态，这个时候created钩子就不会被重复调用了，如果我们的子组件需要在每次加载或切换状态的时候进行某些操作，可以使用activated钩子触发。
父子组件的钩子并不会等待请求返回，请求是异步的，VUE设计也不能因为请求没有响应而不执行后面的钩子。所以，我们必须通过v-if来控制子组件钩子的执行时机.





beforeCreate

在实例初始化之后，数据观测和事件、生命周期初始化配置之前被调用。

created

实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测，属性和方法的运算，事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

beforeMount

在挂载开始之前被调用：相关的 render 函数首次被调用，此时有了虚拟DOM。

mounted

el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子，渲染为真实DOM。

beforeUpdate

在数据更新之前时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。

updated

由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。

值得注意的是：该钩子在服务器端渲染期间不被调用。

beforeDestroy

实例销毁之前调用。此时，实例仍然是可用的。

destroyed

vue 实例销毁后调用。调用后，vue 实例指示的所有东西都会解绑，所有的事件监听器会被卸载移除，所有的子实例也会被销毁。 

值得注意的是：该钩子在服务器端渲染期间不被调用。
```



### vue全家桶

### vue-cli

```
vue-cli也叫脚手架，官方定义为Vue.js 开发的标准工具！相比scirpt标签引入，脚手架具有如下特点：
1）、功能丰富
对 Babel、TypeScript、ESLint、PostCSS、PWA、单元测试和 End-to-end 测试提供开箱即用的支持。
2）、易于扩展
它的插件系统可以让社区根据常见需求构建和共享可复用的解决方案。
3）、无需 Eject
Vue CLI 完全是可配置的，无需 eject。这样你的项目就可以长期保持更新了。
4）、CLI 之上的图形化界面
通过配套的图形化界面创建、开发和管理你的项目。
5）、即刻创建原型
用单个 Vue 文件即刻实践新的灵感。
6）、面向未来
为现代浏览器轻松产出原生的 ES2015 代码，或将你的 Vue 组件构建为原生的 Web Components 组件。

安装

npm install -g @vue/cli
# OR
yarn global add @vue/cli

//安装完成后创建一个项目，vue ui为图形化构建，相对简单（推荐）
vue create my-project
# OR
vue ui
```

### vueRouter

```
vue中的hash模式
即地址栏 URL 中的 # 符号,这个#就是hash符号，中文名哈希符或锚点
比如这个 URL：http://www.baidu.com/#/home，hash 的值为 #/home
它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

路由的哈希模式其实是利用了window.onhashchange事件，也就是说你的url中的哈希值（#后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载


vue中history模式
HTML5 History Interface 中新增的两个神器 pushState() 和 replaceState() 方法（需要特定浏览器支持），用来完成 URL 跳转而无须重新加载页面，不过这种模式还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，就需要前端自己配置404页面。


pushState() 和 replaceState() 这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404（因为浏览器一旦刷新，就是去真正请求服务器资源）

那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效

pushState方法、replaceState方法，只能导致history对象发生变化，从而改变当前地址栏的 URL，但浏览器不会向后端发送请求，也不会触发popstate事件的执行


Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：

1）嵌套的路由/视图表
2）模块化的、基于组件的路由配置
3）路由参数、查询、通配符
4）基于 Vue.js 过渡系统的视图过渡效果
5）细粒度的导航控制
6）带有自动激活的 CSS class 的链接
7）HTML5 历史模式或 hash 模式，在 IE9 中自动降级
8）自定义的滚动条行为

vueRouter 安装

npm install vue-router
//安装后在mainjs引入
import VueRouter from 'vue-router'

Vue.use(VueRouter)


====================
我们这里有两条路由，组成一个routes: 

const routes = [
  { path: '/home', component: Home },
  { path: '/about', component: About }
]
　　最后创建router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受routes 参数。

const router = new VueRouter({
      routes // routes: routes 的简写
})
　　配置完成后，把router 实例注入到 vue 根实例中,就可以使用路由了

const app = new Vue({
  router
}).$mount('#app')

<router-link to="/home/computer">电脑</router-link>
this.$router.push("home"), 就可以跳转到home界面
```

#### 重定向

```
const routes = [
    {
        path:"/home",
        component: home
    },
    {
        path: "/about",
        component: about
    },
    // 重定向
    {
        path: '/', 
        redirect: '/home' 
    }
]
```

#### Vue-router 中hash模式和history模式的区别

```
Vue-router 中hash模式和history模式的关系
hash模式和history模式的不同

最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的

对于vue这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。

为了达到这一目的，浏览器当前提供了以下两种支持：

hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。
因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.

```



### vuex

```
Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。

Vuex是通过全局注入store对象，来实现组件间的状态共享。在大型复杂的项目中（多级组件嵌套），需要实现一个组件更改某个数据，多个组件自动获取更改后的数据进行业务逻辑处理，这时候使用vuex比较合适。假如只是多个组件间传递数据，使用vuex未免有点大材小用，其实只用使用组件间常用的通信方法即可。

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

什么情况下我应该使用 Vuex？
Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。

如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。

安装方法

npm install vuex --save

由上图，我们可以看出Vuex有以下几个部分构成：

1）state

state是存储的单一状态，是存储的基本数据。

2）Getters

getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。

3）Mutations

mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）

4）Actions

actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）

5）Module

Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。

import Vuex from 'vuex';
Vue.use(Vuex); // 1. vue的插件机制，安装vuex
let store = new Vuex.Store({ // 2.实例化store，调用install方法
    state,
    getters,
    modules,
    mutations,
    actions,
    plugins
});
new Vue({ // 3.注入store, 挂载vue实例
    store,
    render: h=>h(app)
}).$mount('#app');
```

##### module 使用场景

##### store.js

 store.js 几个简单的vuex 使用场景模拟。 我们有多个模块，分别为： test1, test2... 

我们使用vuex 需要实例化一个Vuex的Store构造函数。 这里storeInstall 中第一个state, 我们可以理解为根 state, 它全局可访问。 modules 中则是我们自定义注册的module. 每个module 中都有自己独立的state, action, mutation, getter...  

      需要注意的是，这里通过给每个module 对象添加namespaced: true, 来达到命名空间来区分Module的效果。也是通过它来区分更新/调用 对应的vuex 方法来隔离未知数据更新等数据相关问题。
关于vuex module 这里只是个基本讲解。 总结下来就是module 给了我们一种隔离vuex store 各个 state及相关api 的方法，让数据相关操作在复杂的项目场景可以更清晰，易追踪。

```


import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
 
const test1 = {
  namespaced: true,
  state: {
    name: 'moduleA',
    type: 'module A'
  },
  mutations: {
    updateNameByMutation(state, appendStr){
      state.name = state.name + " append Str: " + appendStr
    }
  },
  actions: {
    udpateNameByAction({commit}, appendStr) {
      commit("updateNameByMutation", appendStr)
    }
  },
  getters: {
    getNameA(state){
      return state.name
    }
  }
}
const test2 = {
  // 当namespaced=true 时， vuex, 将会自动给各自module 添加访问路径名。 方便区分moduel
  namespaced: true,
  state:{
    name: 'moduleB',
    type: 'module B'
  },
  mutations: {
    updateNameByMutation(state, appendStr){
      state.name = state.name + " append Str: " + appendStr
    }
  },
  actions: {
    // 如果不使用命名空间， 那么view 指向actions 的该方法时，会执行所有与指定action名相同的函数（即：这里module A,B 中该action都会执行）
    udpateNameByAction({commit}, appendStr){
      commit("updateNameByMutation", appendStr)
    }
  },
  getters: {
    getNameB(state){
      return state.name
    }
  }
}
 
const storeInstall =  new Vuex.Store({
   state: {
     name: 'i am root state name'
   },
   modules:{
    // 这里的路径名： test1, test2, 在view 中 通过 mapActions('test1', [actionName]) 使用并区分需要使用的module
    test1,
    test2
   }
})
 
export default storeInstall
```

##### Test.vue

```
<template>
  <div>
    <div>
    <h2>Page Test1</h2>
    </div>
    <div>
    <a href="javascript:" @click="changeName">udpate: 名称Name</a>  &nbsp; &nbsp;
    <a href="javascript:" @click="showName">显示更新后的Name</a> &nbsp; &nbsp;
    </div>
  </div>
</template>
<script>
import { mapState, mapActions } from 'vuex'
export default {
  data(){
    return {}
  },
  computed: {
    ...mapState('test1', {
      state: state => state
    })
  },
  methods: {
    // test1 模块路径名
    ...mapActions('test1', [
      'udpateNameByAction'
    ]),
    changeName(){
      this["udpateNameByAction"]('ha ha test1 udpate !!')
    },
    showName(){
      console.log(this.$store.state)
    },
  },
  mounted() {
    console.log("store name: ", this.$store)
    console.log("namespace test1 state: ", this.state)
  }
}
</script>
 
```



### Axios

```
Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。
特性
1）从浏览器中创建 XMLHttpRequests
2）从 node.js 创建 http 请求
3）支持 Promise API
4）拦截请求和响应
5）转换请求数据和响应数据
6）取消请求
7）自动转换 JSON 数据
8）客户端支持防御 XSRF

安装方法

 npm install axios
```

### Vue组件通信

```
1、父子通信：

父向子传值，通过props；子向父传值通过events ($emit)；父调用子方法通过ref；provide / inject。
this.$emit('showCityName',data);
Event.$on('input',function (data) {
                self.text = data
            })


父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed

2、兄弟通信：bus

3、跨级嵌套通信：bus；provide / inject等。

vuex
操作行为处理模块,由组件中的$store.dispatch('action 名称', data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state
状态改变操作方法，由actions中的commit('mutation 名称')来触发


父子通信：
父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；ref 也可以访问组件实例；provide / inject API；$attrs/$listeners

兄弟通信：
Bus；Vuex

跨级通信：
Bus；Vuex；provide / inject API、$attrs/$listeners
```

### 路由拦截与请求拦截

```
路由拦截
const routes = [
    {
        path: '/',
        name: '/',
        component: Index
    },
    {
        path: '/repository',
        name: 'repository',
        meta: {
            requireAuth: true,  // 添加该字段，表示进入这个路由是需要登录的
        },
        component: Repository
    },
    {
        path: '/login',
        name: 'login',
        component: Login
    }
];

==========
router.beforeEach((to, from, next) => {
    if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限
        if (store.state.token) {  // 通过vuex state获取当前的token是否存在
            next();
        }
        else {
            next({
                path: '/login',
                query: {redirect: to.fullPath}  // 将跳转的路由path作为参数，登录成功后跳转到该路由
            })
        }
    }
    else {
        next();
    }
})


请求拦截
// http request 拦截器
axios.interceptors.request.use(
    config => {
        if (store.state.token) {  // 判断是否存在token，如果存在的话，则每个http header都加上token
            config.headers.Authorization = `token ${store.state.token}`;
        }
        return config;
    },
    err => {
        return Promise.reject(err);
    });

// http response 拦截器
axios.interceptors.response.use(
    response => {
        return response;
    },
    error => {
        if (error.response) {
            switch (error.response.status) {
                case 401:
                    // 返回 401 清除token信息并跳转到登录页面
                    store.commit(types.LOGOUT);
                    router.replace({
                        path: 'login',
                        query: {redirect: router.currentRoute.fullPath}
                    })
            }
        }
        return Promise.reject(error.response.data)   // 返回接口返回的错误信息
    });
```



### 搭配UI框架

```
搭配UI框架如：iview、vant、elementUI
iview 一套基于 Vue的高质量UI 组件库(分为小程序和pc端等不同版本)；
vant 轻量、可靠的移动端 Vue 组件库,是有赞开源的一套基于 Vue 2.0 的 Mobile 组件库,旨在更快、更简单地开发基于 Vue 的美观易用的移动站点。
Ant Design Vue 是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。
elementUI 是基于 Vue 2.0 桌面端中后台组件库。
```

## webpack

```
cnpm install -D webpack-dev-server
如果反复提醒要安装，npm换cnpm

```

#### Babel

```
Babel转码器
babel是一个广泛使用的ES6转码器，可以将ES6代码转换为ES5代码，从而在老版本浏览器执行。

npm install --save-dev @babel/core
npm install --save-dev @babel/cli
@babel/preset-env，最新转码规则，处理ES6+规范语法的插件合集。如果需要转换react的jsx语法，使用@babel/preset-react，这里我们不需要转换jsx语法，下载一个即可。
Couldn't find preset "@babel/preset-env"
cnpm i -D babel-preset-env

Couldn't resolve extends clause of ./.config/babel.config

npm install babel-preset-env --save

npm install --save-dev @babel/preset-env


compiler.getInfrastructureLogger is not a function【webpack与webpack-cli不兼容】
 
 
首先将之前的安装的版本删除
npm uninstall webpack webpack-cli -g //这是全局删除


重新指定版本下载：
npm install webpack@4.16.5 webpack-cli@3.3.11 -g

yarn global add webpack@4.16.5 webpack-cli@3.3.11

npm start

webpack.config
{
                test: /\.(js|jsx)$/,
                use: [
                    {
                      loader: "babel-loader",
                      options: {
                        "presets": [["es2015", {"modules": false}], "react"]
                      }
                    }
                  ],
            },
   
   
   
   
   
   "babel": {
    "extends": "./.config/babel.config"
  },
            
```



#### 降级

```
cnpm i webpack@3.6.0 -g
cnpm i webpack@4.2.0 -g
cnpm i webpack@3.10.0 -g

npm install -g async


"webpack-dev-server": "^2.4.5"
```



#### 配置

```
webpack 配置

{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  use:[
    {
    loader: 'url-loader',
    options: {
      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
      }
    },
    /*对图片进行压缩*/
    {
      loader: 'image-webpack-loader',
      options: {
        bypassOnDebug: true,
      }
    }
  ]
}
```



#### 对Webpack的理解

```
1.1 背景
Webpack 的目标是实现前端项目的模块化，从而更高效地管理和维护项目中的每一个资源。在早期的前端项目中，我们通过文件划分的形式来实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的 JS 文件中。约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后再调用模块化的成员。比如：


为什么选择 webpack
查看原文|编辑此页
想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。

在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。


目前，前端领域有一些工具能够很好的满足以上这 3 个需求，其中最为主流的就是 Webpack、Parcel 和 Rollup，我们以 Webpack 为例：

Webpack 作为一个模块打包工具，本身就可以解决模块化代码打包的问题，将零散的 JavaScript 代码打包到一个 JS 文件中。

对于有环境兼容问题的代码，Webpack 可以在打包过程中通过 Loader 机制对其实现编译转换，然后再进行打包。

对于不同类型的前端模块类型，Webpack 支持在 JavaScript 中以模块化的方式载入任意类型的资源文件，例如，我们可以通过 Webpack 实现在 JavaScript 中加载 CSS 文件，被加载的 CSS 文件将会通过 style 标签的方式工作。

除此之外，Webpack 还具备代码拆分的能力，它能够将应用中所有的模块按照我们的需要分块打包。这样一来，就不用担心全部代码打包到一起，产生单个文件过大，导致加载慢的问题。我们可以把应用初次加载所必需的模块打包到一起，其他的模块再单独打包，等到应用工作过程中实际需要用到某个模块，再异步加载该模块，实现增量加载，或者叫作渐进式加载，非常适合现代化的大型 Web 应用。

当然，除了 Webpack，其他的打包工具也都类似，总之，所有的打包工具都是以实现模块化为目标，让我们可以在开发阶段更好的享受模块化带来的优势，同时又不必担心模块化在生产环境中产生新的问题。


```

#### 模块

```
支持的模块类型 
通过 loader，webpack 可以支持以各种语言和预处理器语法编写的模块。loader 描述了 webpack 如何处理 非 JavaScript _模块_，并且在 bundle 中引入这些_依赖_。 webpack 社区已经为各种流行语言和语言处理器创建了 loader，包括：

CoffeeScript
TypeScript
ESNext (Babel)
Sass
Less
Stylus
其实还有很多！总的来说，webpack 提供了可定制的、强大和丰富的 API，允许在任何技术栈中使用 webpack，同时在开发、测试和生产环境下的工作流程中做到无侵入性。
```

#### 模块热更新hot module replacement HMR

```
在 HMR runtime 中 
这件事情比较有技术性……如果你对其内部不感兴趣，可以随时跳到 HMR API 页面 或 HMR 指南。

对于模块系统运行时(module system runtime)，会发出额外代码，来跟踪模块 parents 和 children 关系。在管理方面，runtime 支持两个方法 check 和 apply。

check 方法，发送一个 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 ready 状态。

apply 方法，将所有 updated module 标记为无效。对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module（以最先到达为准，冒泡停止）。如果它从入口起点开始冒泡，则此过程失败。

之后，所有无效 module 都会被（通过 dispose handler）处理和解除加载。然后更新当前 hash，并且调用所有 accept handler。runtime 切换回 idle 状态，一切照常继续。
```



#### 热更新的原理

```
（1）webpack 对文件系统进行 watch 打包到内存中

依赖webpack-dev-middleware，它会调用 webpack 的 api 对文件系统 watch
webpack-dev-middleware依赖memory-fs库，它将webpack 原本的 outputFileSystem 替换成了MemoryFileSystem 实例，这样代码就将输出到内存中
（2）devServer 通知浏览器端文件发生改变

在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接。
webpack-dev-server 调用 webpack api监听 compile的 done 事件，将编译打包后的新模块 hash 值发送到浏览器端。
（3）webpack-dev-server/client 接收到服务端消息做出响应

webpack-dev-server默认修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。
webpack-dev-server/client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作(根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）).
（4）webpack 接收到最新 hash 值验证并请求模块代码

webpack/hot/dev-server监听webpack-dev-server/client发出的webpackHotUpdate 消息。
先调用hotDownloadManifest（ajax请求）来获取更新的文件列表。
再调用hotDownloadUpdateChunk获取更新的新模块代码
（5）HotModuleReplacement.runtime 对模块进行热更新

找出过期的模块和过期的依赖
从缓存中删除过期的模块和依赖
将新的模块添加到 modules 中
————————————————

```



#### Webpack作用

```
编译代码能力，提高效率，解决浏览器兼容问题

模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题

万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制。
```



#### webpack的构建流程

```
webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来。在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变Webpack的运作。

从启动到结束会依次经历三大流程： -

初始化阶段：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数。 - 

编译构建阶段：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。 - 

输出阶段：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。
```

#### 除了Webpack外，你还了解哪些模块管理工具

```
10.1 Rollup
Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。

10.2 Parcel
Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。

10.3 Vite
Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。

Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译

Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。

Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。
```

#### loader和plugin的不同

```
不同的作用

Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析 非JavaScript文件 的能力。
Plugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。


不同的用法

Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。
```

## node

```

```

### 面试

```
1、你了解 Node. js吗？

Node. js是一个基于 Chrome v8引擎的服务器端 JavaScript运行环境；Node. js是一个事件驱动、非阻塞式I/O的模型，轻量而又高效；Node. js的包管理器npm是全球最大的开源库生态系统。

2、Node. js的使用场景是什么？

高并发、实时聊天、实时消息推送、客户端逻辑强大的SPA（单页面应用程序）。

3、为什么要用 Node. js？

原因如下。

（1）简单， Node. js用 JavaScript、JSON进行编码，简单好学。

（2）功能强大，非阻塞式I/O，在较慢的网络环境中，可以分块传输数据，事件驱动，擅长高并发访问。

（3）轻量级， Node. js本身既是代码又是服务器，前后端使用同一语言。

（4）可扩展，可以轻松应对多实例、多服务器架构，同时有海量的第三方应用组件。

4、Node. js有哪些全局对象？

global、 process, console、 module和 exports。

5、process有哪些常用方法？

process.stdin、 process.stdout、 process.stderr、process.on、 process.env、 process.argv、 process.arch、process.platform、 process.exit

6、console有哪些常用方法？

console.log/console. info、console.error/console.warning、console.time/console.timeEnd 、console.trace、console .table。

7、Node.js有哪些定时功能？

setTimeout/clearTimeout, setInterval/clearInterval、 setImmediate/clearImmediate、 process. nextTick。

8、Node. js中的事件循环是什么样的？

事件循环其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列。

执行中的事件叫IO事件， setlmmediate在当前队列中立即执行，setTimout/setInterval把执行定时到下一个队列， process. nextTick在当前队列执行完，下次遍历前执行。所以总体顺序是：IO事件→ setImmediate→ setTimeout/setInterval→ process. nextTick。

9、如何应用 Node. js中的 Buffer？

Buffer是用来处理二进制数据的，比如图片、MP3、数据库文件等。Buffer支持各种编码解码、二进制字符串互转。

10、Node. js中的异步和同步如何理解？

Node.js是单线程的，异步是通过一次次的循环事件队列来实现的。同步则是阻塞式的IO，这在高并发环境中会是一个很大的性能问题，所以同步一般只在基础框架启动时使用，用来加载配置文件、初始化程序等。

11、通过哪些方法可以进行异步流程的控制？

通过以下方法可以进行异步流程的控制。

（1）多层嵌套回调。

（2）为每一个回调写单独的函数，函数里边再回调。

（3）用第三方框架，如 async、q、 promise等。

12、通过哪些常用方法可以防止程序崩溃？

通过以下方法可以防止程序崩溃。

（1） try-catch-finally。

（2） EventEmitter/Stream error事件处理。

（3） domain统一控制。

（4） jshint静态检查。

（5） jasmine/mocha单元测试。

13、怎样调试 Node. js程序？

用node-- debug app. js和 node-inspector。

14、Node .js的网络模块都有哪些？

Node. js全面支持各种网络服务器和客户端，包括TCP、HTP/ HTTPS、TCP 、UDP、DNS、tls/ssl等。

15、Node.js是怎样支持 HTTPS、tls的？

主要通过以下几个步骤支持。

（1）使用 openssl生成公钥、私钥。

（2）服务器或客户端使用HTTPS替代HTTP。

（3）服务器或客户端加载公钥、私钥证书。

16、什么是 Node. js？

Node. js是一个 JavaScript的运行环境，是一个服务器端的“ JavaScript解释器”，用于方便高效地搭建一些响应速度快、易于扩展的网络应用。它采用事件驱动、异步编程方式，为网络服务而设计。

17、Node. js的优缺点是什么？

优点如下：

（1） Node. js是基于事件驱动和无阻塞的，非常适合处理并发请求，因此构建在 Node. js的代理服务器相比其他技术实现的服务器要好一点。

（2）与 Node. js代理服务器交互的客户端代码由 JavaScript语言编写，客户端与服务端都采用一种语言编写。

缺点如下：

（1） Node .js是一个相对新的开源项目，不太稳定，变化速度快。

（2）不适合CPU密集型应用，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。

18、npm是什么？

npm是 Node. js中管理和分发包的工具，可用于安装、卸载、发布、查看包等。

19、npm的好处是什么？

通过ηpm，可以安装和管理项目的依赖，还可以指明依赖项的具体版本号。

20、Node. js中导入模块和导入 JavaScript文件在写法上有什么区别？

在 Node. js中要导入模块，直接使用名字导入即可，如下所示：

var express = require（"express"）；
要导入 JavaScript文件，需要使用文件的路径，如下所示：

var demo = require（"./demo.js"）；
21、npm的作用是什么？

npm是同 Node .js一起安装的包管理工具，能解决 Node. js代码部署上的很多问题。常见的使用场景有以下几种。

（1）允许用户从npm服务器下载别人编写的第三方包到本地。

（2）允许用户从npm服务器下载并安装别人编写的命令行程序到本地。

（3）允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。

22、什么是 EventEmitter？

EventEmitter是 Node. js中一个实现观察者模式的类，主要功能是订阅和发布消息，用于解决多模块交互而产生的模块之间的耦合问题.

23、如何实现一个 EventEmitter？

可通过3步实现 EventEmitter定义一个子类，通过寄生组合式继承，继承 EventEmitter

父类，代码如下。

var Util= require('util' );
 var EventEmitter= require ('events' ) .EventEmitter；
function  IcktEmitter () {
    EventEmitter .apply(this, arguments)
}
Util.inherits(IcktEmitter, EventEmitter);
 
 
 
 
var ie = new IcktEmitter ( ) ;
   ie.on('icketang'， function（data）{
       console.log('接收到消息'，data )
})
ie.emit（' icketang'，'来自有课网的消息'）；
24、EventEmitter有哪些典型应用？

有以下应用。

（1）在模块间传递消息。

（2）在回调函数内外传递消息。

（3）处理流数据，因为流是在 EventEmitter的基础上实现的。

（4）运用观察者模式收发消息的相关应用。

25、如何捕获 EventEmitter的错误事件？

当发布error消息的时候，如果没有注册该事件，应用程序会抛出错误并中断执行。所以要监听error事件，代码如下。

var ie= new IcktEmitter ( );
 ie .on（'error '， function（err）{
 conso1e.1og ( '接收到错误的信息'，err )
})
ie.emit（' error'，'来自ie1的错误消息'）；
26、Node. js中的流是什么？

流(Stream)是基于 EventEmitter的数据管理模式，由各种不同的抽象接口组成，主要包括可写、可读、可读写、可转换等类型。

27、使用流有什么好处？

流是非阻塞式数据处理模式，可以提升效率，节省内存，有助于处理管道且可扩展等。

28、流有哪些典型应用？

流在文件读写、网络请求、数据转换、音频、视频等方面有很广泛的应用。

29、如何捕获流的错误事件？

监听error事件，方法与订阅 EventEmitter的error事件相似。

30、有哪些常用 Stream流？分别什么时候使用？

Readable流为可读流，在作为输入数据源时使用；Writable流为可写流，在作为输岀源时使用；Duplex流为可读写流，它作为输岀源被写入，同时又作为输入源被后面的流读出。

Transform流和 Duplex流一样，都是双向流，区别是 Transfrom流只需要实现一个函数 _transfrom( chunk, encoding, callback)；而 Duplex流需要分别实现_read(size )函数和_write( chunk, encoding, callback ）函数。

31、如何实现一个 Writable流？

实现 Writable流分成3步

（1）引入 Writable模块。

（2）继承 Writable模块。

（3）实现 _write(chunk, encoding, callback )写入函数。

代码如下。

//引入 Writable模块
var Writable= require（'stream'）.Writable；
var Util = require（'util'）；
//继承 Writable模块
function IcktWritable( ) {
  Writable. apply(this, arguments ) ;
}
Util.inherits ( IcktWritable, Writable ) ;
//实现 write函数
IcktWritable. prototype. _write = function ( data, encoding, callback ) {
      console.log ('被写入的数据是：' ，data. toString ( ) )
callback ( )
}
var iw= new IcktWritable ( ) ；
for (var i=0；i< 5 ；i++ ) {
iw. write（'有课网'+i，'utf8"）
}
iw,end('学技能就上有课网' )；
32、内置的fs模块架构由哪几部分组成？

fs模块主要由下面几部分组成。

（1） POSIX文件 Wrapper，对应操作系统的原生文件操作。

（2）文件流，fs. createReadStream和 fs.createWriteStrean。

（3）同步文件读写， fs.readFileSync和fs.writeFileSync。

（4）异步文件读写， fs.readFile和fs.writeFile。

33、读写一个文件有多少种方法？

总体来说，有4种方法。

（1） POSIX式底层读写。

（2）流式读写。

（3）同步文件读写。

（4）异步文件读写。

34、如何读取JSON配置文件？

主要有两种方式。第一种是利用 Node. js内置的 require（ data.json！）机制，直接得到 Javascript对象；

第二种是读入文件内容，然后用JSON. parse（ content）转换成 JavaScript对象。

二者的区别是，对于第一种方式，如果多个模块都加载了同一个JSON文件，那么其中一个改变了 JavaScript对象，其他也跟着改变，这是由 Node.js模块的缓存机制造成的，缓存中只有一个 JavaScript模块对象；

第二种方式则可以随意改变加载后的JavaScript变量，而且各模块互不影响，因为它们都是独立的，存储的是多个 JavaScript对象。

35、fs.watch和 fs.watchFile有什么区别？

二者主要用来监听文件变动，fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统；fs. watchFile则定期检查文件状态变更，适用于网络文件系统，但是与fs.watch相比有些慢，因为它不采用实时机制。

36、为什么需要子进程？

Node. js是异步非阻塞的，这对高并发非常有效。可是我们还有其他一些常用的需求，比如和操作系统 shell命令交互，调用可执行文件，创建子进程，进行阻塞式访问或高CPU计算等，子进程就是为满足这些需求而产生的。顾名思义，子进程就是把 Node. js阻塞的工作交给子进程去做。

37、exec、 execFile、 spawn和fork都是做什么用的？

它们的作用分别如下。

exec可以用操作系统原生的方式执行各种命令，如管道 cat ab. txt |  grep hello。

execFile用于执行一个文件。

spawn负责在流式和操作系统之间进行交互。

fork负责在两个 Node. js程序（ JavaScript）之间进行交互。

38、如何实现一个简单的命令行交互程序？

实现代码如下。

var cp = require (' child process )；
//执行指令
var child= cp .spawn（'echo', ['hello, ''] )；
// child.stdout是输入流， process. stdout是输出流
//子进程的输出流作为当前程序的输入流，然后重定向到当前程序的控制器输出
child. stdout. pipe（process. stdout）
39、两个 Node. js程序之间如何交互？

通过fork实现父子程序之间的交互。子程序用 process.on、 process. send访问父程序，父程序用 child.on、 child.send访问子程序。

关于 parent. JS的示例代码如下。

var cp = require (' child_process' ) ;
 var child= cp.fork ('./child. js' );
child .on（'message'， function（msg）{
 console.1og（'子程序发送的数据：'，msg )
})
child.send ( '来自父程序发送的数据' )
关于 child .js的示例代码如下。

process .on ( 'message' , function（msg）{
conso1e.1og ( '父程序发送的数据: ' , msg )
process.send ( '来自子程序发送的数据' )
40、如何让一个 JavaScript文件变得像 Linux命令一样可执行？

具体步骤如下。

（1）在文件头部加入#！/ bin/sh

如 icketang40.js
#！/bin/sh
echo'有课网— 技能学习就上有课网；
（2）用 chmod命令把名为 icketang40的 JavaScript文件改为可执行文件。

chmod + x  icketang40.js
（3）进入文件目录，在命令行输入 icketang40.js就相当于执行 node icketang40.js

$ ./icketang40.js
执行结果。

41、子进程和进程的 stdin、 stdout、 stderror是样的吗？

概念都是一样的。stdin、 stdout、 stderror分别是输入、输出、错误。三者都是流。区别是在父进程里，子进程的 stdout是输入流， stdin是输出流。

42、async都有哪些常用方法？分别怎么用？

async是一个 JavaScript类库，它的目的是解决 JavaScript中异常流程难以控制的问题。async不仅在 Node. js里适用，还可以用在浏览器中。其常用方法和用法如下。

具体代码如下所示。

var async = require（'async '）；
var date = Date .now ( )；
（1） async. parallel：并行执行完多个函数后，调用结束函数。不用等到前一个函数。执行完再执行下一个函数。

async .parallel ( [
     function ( callback ) {
        setTimeout (function () {
console. log（'process one'， Date. now ( ) - date)
callback（null, 'msg one'）
}，2000)
}，
function ( callback ){
setTimeout ( function () {
console. log（'process tow'， Date .now ( ) - date )
callback ( null, 'msg tow' )
}，1000)
}
]， function（err, result）{
  console. log（err, result, 'done ')
})
（2） async.series：串行执行完多个函数后，调用结束函数。前面一个函数执行完之后，就会立即执行下一个函数。

async .series ( [
function ( callback ) {
setTimeout ( function () {
console. log ( 'process one ', Date. now ( ) - date )
callback ( null, ' msg one'  )
}，2000 )
},
function ( callback )  {
setTimeout ( function () {
console. log ( 'process tow'， Date. now ( ) - date )
callback ( null, 'msg tow ' )
}，1000 )
   }
] ， function (err, result ) {
console. log（err, result, 'done'）
})
（3） async. waterfall：依次执行多个函数，前一个函数的执行结果作为后一个函数执行时的参数。

async .waterfall ( [
function ( callback ) {
setTimeout ( function () {
console. log（'process one, Date. now（）- date）
callback（null, 'msg one'）
}，2000）
},
function（argl, callback）{
 setTimeout （function（）{
console. log（'process tow, Date. now  ( ) - date, argl )
callback（null, 'msg tow'）
}，1000)
}
] , function（err, result）{
console. log（err, result, 'done '）
})
43、express项目的目录大致是什么结构的？

首先，执行安装 express的指令：npm install express-generator-g。

然后，通过 express指令创建项目：express icketang。

创建的项目目录结构如下。

./app.js  应用核心配置文件（入口文件）

./bin  存放启动项目的脚本文件

./ package.json  存储项目的信息及模块依赖

./public 静态文件（css、js、img等）

./routes 路由文件（MVC中的 contro1ler）

./views 页面文件（jade模板）

44、express常用函数有哪些？

常用函数有以下几个

express .Router—路由组件

app.get—路由定向。

app. configure——配置。

app.set一设定参数。

app.use——使用中间件。

45、express中如何获取路由的参数？

执行的命令如下

/users/：name
使用 req.params.name来获取；使用req.body.username来获得表单传入参数 username；express的路由支持常用通配符有？、+、*、( )。

46、express  response有哪些常用方法？

常用方法有以下几个。

res. download( )，弹出文件下载。

res.end ( )，结束响应。

res.json( )，返回json。

res.jsonp( )，返回 jsonp。

res .redirect ( )，重定向请求。

res .render ( )，渲染模板。

res.send ( )，返回多种形式数据。

res.sendFile  ( )，返回文件。

res.sendStatus( )，返回状态。

47、mongodb有哪些常用优化措施？

常用优化措施如下。

（1）优化预读。

（2）禁用NUMA。

（3）不要记录访问时间等。

48、Redis的主要特点是什么？

主要特点如下。

（1） Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载和使用。

（2） Redis不仅支持简单的键-值类型的数据，同时还提供list、set、zset、hash等数据结构的存储。

（3） Redis支持数据的备份，即主-从模式的数据备份。

49、Nginx和 Apache有什么区别？

Nginx是轻量级的，同样的Web服务在 nginx中会占用更少的内存和资源。Nginx抗并发，处理请求的方式是异步非阻塞的，负载能力比 Apache高很多，而 Apache则是阻塞型的。

在高并发下 Nginx能保持低资源、低消耗、高性能，并且处理静态文件比 Apache好。 

Nginx的设计高度模块化，编写模块相对简单，配置简洁。作为负載均衡服务器，支持7层负载均衡，是一个反向代理服务器。

社区活跃，各种高性能模块出品迅速。Apache的 rewrite比 Nginx强大，模块丰富。Apache发展得更为成熟，Bug很少,更加稳定。

Apache对PHP的支持比较简单， Nginx需要配合其他后端使用。Apache处理动态请求有优势，拥有丰富的特性、成熟的技术和开发社区。

50、说说线程与进程的区别。

（1）一个程序至少有一个进程，一个进程至少有一个线程

（2）线程的划分尺度小于进程，使得多线程程序的并发性高。

（3）进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的运行效率。

（4）线程在执行过程中与进程有区别。每个独立的线程都有程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

（5）从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看作多个独立的应用来实现进程的调度、管理和资源分配。这是进程和线程的主要区别。

51、你知道哪些 Node.js核心模块？

EventEmitter 、Stream、FS、Net和全局对象等。

52、说说 MySQL和 MongoDB的区别。

（1） MySQL是传统的关系型数据库， MongoDB则是非关系型数据库。

（2） MongoDB以BSON结构进行存储，在存储海量数据方面有着很明显的优势。

（3）与传统关系型数据库相比， NoSQL有着非常显著的性能和扩展性优势。

（4）与传统的关系型数据库（如与 MySQL）相比， MongoDB的优点如下。

弱一致性（最终一致），更能保证用户的访问速度。

使用文档结构的存储方式，能够更便捷地获取数据。

53、谈谈栈和堆的区别。

区别如下：

（1）栈（ stack）区由编译器自动分配和释放，存放函数的参数值、局部变量的值等。

堆（heap）区一般由程序员分配和释放，若程序员不释放，程序结束时可能由OS回收。

（2）堆（数据结构）可以被看成一棵树，如堆排序。栈（数据结构）是一种先进后出的数据结构。

END
```



## ES6



### 箭头函数与this

```
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }.bind(this));
};
==================================
function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(character => this.name + character);
};

使用箭头函数，再也不用考虑 this 的问题了。简化了this的写法

var squares = arr.map(function (x) { return x * x }); // Function Expression

const arr = [1, 2, 3, 4, 5];
const squares = arr.map(x => x * x); // Arrow Function for terser implementation

也可以简化函数的写法




```

### 字符串新增了.includes()` 和 `.repeat()

```
var string = 'food';
var substring = 'foo';

console.log(string.indexOf(substring) > -1);
===================
const string = 'food';
const substring = 'foo';

console.log(string.includes(substring)); // true

function repeat(string, count) {
    var strings = [];
    while(strings.length < count) {
        strings.push(string);
    }
    return strings.join('');
}

// String.repeat(numberOfRepetitions)
'meow'.repeat(3); // 'meowmeowmeow'
```

### **字符串模板字面量**`${age} 

```
*可以在字符串中直接使用特殊字符，而不用转义`
var text = "This string contains \"double quotes\" which are escaped.";
let text = `This string contains "double quotes" which don't need to be escaped anymore.`;

*还支持直接插入变量
var name = 'Tiger';
var age = 13;

console.log('My cat is named ' + name + ' and is ' + age + ' years old.');

============
const name = 'Tiger';
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);

*换行
let text = ( `cat
dog
nickelodeon`
);

*使用表达式
let today = new Date();
let text = `The time and date is ${today.toLocaleString()}`;

```

### 数组去重

```
Set：数据结构，类似数组，成员唯一
...：（展开/剩余）运算符，展开数组和对象；

...使用

//展开
let a = [1,2,3];
console.log(...a);
输出： 1 2 3
Set使用

let a = [1,1,1,1,2,2,2]
let b = new Set(a)

输出b: Set{1,2}
结合两者

 var a = [1,2,2,2,3];
 a = [...new Set(a)];
 输出 a = [1,2];
首先 new Set(a) 为 Set{1,2}
然后...将 new Set(a)展开，为: 1 2
最后，放入a中，实现去重

```



### 解构数组和对象

简化代码

```
var arr = [1, 2, 3, 4];
var a = arr[0];
var b = arr[1];
var c = arr[2];
var d = arr[3];
==========
let [a, b, c, d] = [1, 2, 3, 4];

console.log(a); // 1
console.log(b); // 2
========

var luke = { occupation: 'jedi', father: 'anakin' };
var occupation = luke.occupation; // 'jedi'
var father = luke.father; // 'anakin'

===========
let luke = { occupation: 'jedi', father: 'anakin' };
let {occupation, father} = luke;

console.log(occupation); // 'jedi'
console.log(father); // 'anakin'



```

### Modules export

ES6之前，浏览器端的模块化代码，我们使用像[Browserify](https://link.jianshu.com?t=http://browserify.org/)这样的库，
 在 **Node.js** 中，我们则使用 [require](https://link.jianshu.com?t=https://nodejs.org/api/modules.html#modules_module_require_id)。
 在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。



三. export default



某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名,这个时候就可以使用export default

![img](https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210508_d7a3f47a-af91-11eb-bcae-38f9d3cd240d.png)

这里的引用myFunc是我自己命名的，你可以根据需要命名它对应的名字

![img](https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210508_d7aa98a2-af91-11eb-bcae-38f9d3cd240d.png)

注意：export default在同一个模块中，不允许同时存在多个





```
Exporting in CommonJS
module.exports = 1;
module.exports = { foo: 'bar' };
module.exports = ['foo', 'bar'];
module.exports = function bar () {};

Exporting in ES6
要导出一个变量，那么使用 变量名 ：
export let name = 'David';
export let age  = 25;​​

===
为对象 导出一个列表
function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

export { sumTwo, sumThree };


导出一个结果值
export function sumTwo(a, b) {
    return a + b;
}

export function sumThree(a, b, c) {
    return a + b + c;
}


 导出一个默认出口
 
function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

let api = {
    sumTwo,
    sumThree
};

export default api;


总是在模块的 最后 使用 export default 方法。
它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。
更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。
最受这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。

```

### Import

```
单独引入一个文件
import 'underscore';
这里需要注意的是， 整个文件的引入方式会执行该文件内的最上层代码

像Python一样，我们还可以命名引用：
import { sumTwo, sumThree } from 'math/addition';

使用 as 给这些模块重命名
import {
    sumTwo as addTwoNumbers,
    sumThree as sumThreeNumbers
} from 'math/addition';

引入所有的东西
import * as util from 'math/addition';

可以从一个模块的众多值中引入一个列表
import * as additionUtil from 'math/addtion';
const { sumTwo, sumThree } = additionUtil;

引用默认对象
import api from 'math/addition';
// Same as: import { default as api } from 'math/addition';
我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的：
==========
// foos.js
export { foo as default, foo1, foo2 };

import foo, { foo1, foo2 } from 'foos';

导入commonjs模块，例如React：
import React from 'react';
const { Component, PropTypes } = React;
更简化版本
import React, { Component, PropTypes } from 'react';

注意：被导出的值是被 绑定的（原文：bingdings），而不是引用。
所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。


```

### Parameters

在ES5中，许多种方法来处理函数的 **参数默认值（default values）**，**参数数量（indefinite arguments）**，**参数命名（named parameters）**。
 ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。



```
function addTwoNumbers(x, y) {
    x = x || 0;
    y = y || 0;
    return x + y;
}


===========
function addTwoNumbers(x=0, y=0) {
    return x + y;
}
addTwoNumbers(2, 4); // 6
addTwoNumbers(2); // 2
addTwoNumbers(); // 0

*Rest Parameters ...
ES5中，遇到参数数量不确定时，我们只能如此处理：
function logArguments() {
    for (var i=0; i < arguments.length; i++) {
        console.log(arguments[i]);
    }
}
使用 rest 操作符，我们可以给函数传入一个不确定数量的参数列表：
function logArguments(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}


ES5中，当我们要处理多个 命名参数 时，通常会传入一个 选项对象 的方式，这种方式被jQuery采用。
function initializeCanvas(options) {
    var height = options.height || 600;
    var width  = options.width  || 400;
    var lineStroke = options.lineStroke || 'black';
}

=============
function initializeCanvas(
    { height=600, width=400, lineStroke='black'}) {
        // ...
    }
    // Use variables height, width, lineStroke here
    如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了：
    function initializeCanvas(
    { height=600, width=400, lineStroke='black'} = {}) {
        // ...
    }
    
我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入：
Math.max(...[-1, 100, 9001, -32]); // 9001


```

### Classes

```
在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样：
function Person(name, age, gender) {
    this.name   = name;
    this.age    = age;
    this.gender = gender;
}

Person.prototype.incrementAge = function () {
    return this.age += 1;
};
继承父类的子类需要这样：
function Personal(name, age, gender, occupation, hobby) {
    Person.call(this, name, age, gender);
    this.occupation = occupation;
    this.hobby = hobby;
}

Personal.prototype = Object.create(Person.prototype);
Personal.prototype.constructor = Personal;
Personal.prototype.incrementAge = function () {
    return Person.prototype.incrementAge.call(this) += 20;
};

ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类：

class Person {
    constructor(name, age, gender) {
        this.name   = name;
        this.age    = age;
        this.gender = gender;
    }

    incrementAge() {
      this.age += 1;
    }
}
继承父类的子类只要简单的使用 extends 关键字就可以了：加上super，函数，变量的继承

Person.call(this, name, age, gender); 
super(name, age, gender);


class Personal extends Person {
    constructor(name, age, gender, occupation, hobby) {
        super(name, age, gender);
        this.occupation = occupation;
        this.hobby = hobby;
    }

    incrementAge() {
        super.incrementAge();
        this.age += 20;
        console.log(this.age);
    }
}


```

### Symbols

用的少

```
调用 Symbol() 或者 Symbol(描述文本) 会创建一个唯一的、在全局中不可以访问的符号对象。
一个 Symbol() 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。
举个例子，如果你想给 React.Component 这个类添加一个 refreshComponent 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做：

const refreshComponent = Symbol();

React.Component.prototype[refreshComponent] = () => {
    // do something
}
```

### Maps

```
Maps 让我们使用 set，get 和 search 操作数据。
let map = new Map();
> map.set('name', 'david');
> map.get('name'); // david
> map.has('name'); // true
Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。

let map = new Map([
    ['name', 'david'],
    [true, 'false'],
    [1, 'one'],
    [{}, 'object'],
    [function () {}, 'function']
]);

for (let key of map.keys()) {
    console.log(typeof key);
    // > string, boolean, number, object, function
}
我们还可以使用 .entries() 方法来遍历整个map对象：
for (let [key, value] of map.entries()) {
    console.log(key, value);
}

```

### WeakMaps

```
在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定：
class Person {
    constructor(age) {
        this._age = age;
    }

    _incrementAge() {
        this._age += 1;
    }
}

使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 Reflect.ownKeys()：
> const person = new Person(50);
> person.incrementAge(); // 'Midlife crisis'
> Reflect.ownKeys(person); // []

一个使用WeakMaps存储数据更实际的例子，就是有关于一个DOM元素和对该DOM元素（有污染）地操作：
let map = new WeakMap();
let el  = document.getElementById('someElement');

// Store a weak reference to the element with a key
map.set(el, 'reference');

// Access the value of the element
let value = map.get(el); // 'reference'

// Remove the reference
el.parentNode.removeChild(el);
el = null;

value = map.get(el); // undefined

上面的例子中，一个对象被垃圾回收期给销毁了，WeakMaps会自动的把自己内部所对应的键值对数据同时销毁。

提示：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的，使用了WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。
通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常适合的。


```

### Promises

```
Promises让我们让我们多缩进难看的代码（回调地狱）：
func1(function (value1) {
    func2(value1, function (value2) {
        func3(value2, function (value3) {
            func4(value3, function (value4) {
                func5(value4, function (value5) {
                    // Do something with value 5
                });
            });
        });
    });
});

写成这样：
func1(value1)
    .then(func2)
    .then(func3)
    .then(func4)
    .then(func5, value5 => {
        // Do something with value 5
    });
    
原生版本的 Promises：
new Promise((resolve, reject) =>
    reject(new Error('Failed to fulfill Promise')))
        .catch(reason => console.log(reason));
        
这里有两个处理函数，resolve（当Promise执行成功完毕时调用的回调函数） 和 reject （当Promise执行不接受时调用的回调函数）

var fetchJSON = function(url) {
    return new Promise((resolve, reject) => {
        $.getJSON(url)
            .done((json) => resolve(json))
            .fail((xhr, status, err) => reject(status + err.message));
    });
};

我们还可以使用 Promise.all() 来异步的 并行 处理一个数组的数据。
var urls = [
    'http://www.api.com/items/1234',
    'http://www.api.com/items/4567'
];

var urlPromises = urls.map(fetchJSON);

Promise.all(urlPromises)
    .then(function (results) {
        results.forEach(function (data) {
        });
    })
    .catch(function (err) {
        console.log('Failed: ', err);
    });

```

### Generators

就像[Promises](https://link.jianshu.com?t=https://github.com/DrkSephy/es6-cheatsheet#promises)如何让我们避免[回调地狱](https://link.jianshu.com?t=http://callbackhell.com/)一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。
 Generators实际上是支持[暂停运行](https://link.jianshu.com?t=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield)，随后根据上一步的返回值再继续运行的一种函数。



```
function* sillyGenerator() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var generator = sillyGenerator();
> console.log(generator.next()); // { value: 1, done: false }
> console.log(generator.next()); // { value: 2, done: false }
> console.log(generator.next()); // { value: 3, done: false }
> console.log(generator.next()); // { value: 4, done: false }

就像上面的例子，当next运行时，它会把我们的generator向前“推动”，同时执行新的表达式。
我们能利用Generators来像书写同步代码一样书写异步代码。

// Hiding asynchronousity with Generators

function request(url) {
    getJSON(url, function(response) {
        generator.next(response);
    });
}
这里我们写个generator函数将要返回我们的数据：
function* getData() {
    var entry1 = yield request('http://some_api/item1');
    var data1  = JSON.parse(entry1);
    var entry2 = yield request('http://some_api/item2');
    var data2  = JSON.parse(entry2);
}
借助于 yield，我们可以保证 entry1 确实拿到数据并转换后再赋值给 data1。

我们再写一个函数，其中使用 next 来步进我们的generator的同事，再利用我们上面的 request 方法来产生（yield）一个Promise。
function request(url) {
    return new Promise((resolve, reject) => {
        getJSON(url, resolve);
    });
}
=====
function iterateGenerator(gen) {
    var generator = gen();
    var ret;
    (function iterate(val) {
        ret = generator.next();
        if(!ret.done) {
            ret.value.then(iterate);
        }
    })();
}
在Generator中引入了Promises后，我们就可以通过Promise的 .catch 和 reject 来捕捉和处理错误了。
使用了我们新版的Generator后，新版的调用就像老版本一样简单可读


```

### Async Await

`async await` 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子：

```
var request = require('request');

function getJSON(url) {
  return new Promise(function(resolve, reject) {
    request(url, function(error, response, body) {
      resolve(body);
    });
  });
}

async function main() {
  var data = await getJSON();
  console.log(data); // NOT undefined!
}

main();

它们看上去和Generators很像。强烈推荐使用 async await 来替代Generators + Promises的写法。
```

